<!DOCTYPE html>
<html>
  <head>
    <title></title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="shortcut icon" href="images/favicon.png" type="image/x-icon" />
<link href="/booklet-Scraping/html/_support/html/css/font-awesome.min.css" rel="stylesheet">
<link href="/booklet-Scraping/html/_support/html/css/nucleus.css" rel="stylesheet">
<link href="/booklet-Scraping/html/_support/html/css/flex.css" rel="stylesheet">
<link rel="stylesheet" href="/booklet-Scraping/html/_support/html/highlightjs/styles/default.css">
<link rel="stylesheet" href="/booklet-Scraping/html/_support/html/css/highlight-commands.css">
<link rel="stylesheet" href="/booklet-Scraping/html/_support/html/css/bootstrap.min.css">
<script src="/booklet-Scraping/html/_support/html/js/jquery-2.x.min.js"></script>
<script src="/booklet-Scraping/html/_support/html/highlightjs/highlight.pack.js"></script>
<script src="/booklet-Scraping/html/_support/html/js/highlight-commands.js"></script>
<meta name="description" content="">
<meta name="author" content="StÃ©phane Ducasse and Peter Kenny">
  </head>
  <body>
    <header>
  <div class="logo">
    <a class="baselink" href="/booklet-Scraping/html"></a>
  </div>
  <div class="burger"><a href="javascript:void(0);" style="font-size:15px;">&#9776;</a></div>
  
</header>
<article>
  <aside>
    <ul class="menu">
   		<li data-nav-id="123" class="dd-item">
    		<a href="/booklet-Scraping/html">
		       <i class="fa fa-fw fa-home"></i>
	    	</a>
        </li>

		
		  <li class="dd-item  haschildren ">
			<div>
			  <a href="/booklet-Scraping/html/Chapters/XPath.html#little journey into xpath">
					Little Journey into XPath
			  </a>
			   <i class="fa fa-angle-right fa-lg category-icon"></i> 
			</div>
			  <ul class="dd-item">
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Scraping/html/Chapters/XPath.html#getting started">
							Getting started
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Scraping/html/Chapters/XPath.html#an example">
							An example
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Scraping/html/Chapters/XPath.html#creating a tree of objects">
							Creating a tree of objects
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Scraping/html/Chapters/XPath.html#nodes, node sets and atomic values">
							Nodes, node sets and atomic values
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Scraping/html/Chapters/XPath.html#basic tree relationships">
							Basic tree relationships
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Scraping/html/Chapters/XPath.html#a large example">
							A large example
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item  haschildren ">
					<div>
						<a href="/booklet-Scraping/html/Chapters/XPath.html#node selection">
							Node selection
						</a>
						<i class="fa fa-angle-right fa-lg category-icon"></i>
					</div>

					<ul class="dd-item">
							
						<li class="dd-item">
							<a href="/booklet-Scraping/html/Chapters/XPath.html#node tag name selection">Node tag name selection</a>
						</li>
							
						<li class="dd-item">
							<a href="/booklet-Scraping/html/Chapters/XPath.html#context and parent">Context and parent</a>
						</li>
							
						<li class="dd-item">
							<a href="/booklet-Scraping/html/Chapters/XPath.html#matching path-based child nodes">Matching path-based child nodes</a>
						</li>
							
						<li class="dd-item">
							<a href="/booklet-Scraping/html/Chapters/XPath.html#matching deep nodes">Matching deep nodes</a>
						</li>
							
						<li class="dd-item">
							<a href="/booklet-Scraping/html/Chapters/XPath.html#identifying attributes">Identifying attributes</a>
						</li>
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item  haschildren ">
					<div>
						<a href="/booklet-Scraping/html/Chapters/XPath.html#predicates">
							Predicates
						</a>
						<i class="fa fa-angle-right fa-lg category-icon"></i>
					</div>

					<ul class="dd-item">
							
						<li class="dd-item">
							<a href="/booklet-Scraping/html/Chapters/XPath.html#first element">First element</a>
						</li>
							
						<li class="dd-item">
							<a href="/booklet-Scraping/html/Chapters/XPath.html#other position functions">Other position functions</a>
						</li>
							
						<li class="dd-item">
							<a href="/booklet-Scraping/html/Chapters/XPath.html#selecting based on node value">Selecting based on node value</a>
						</li>
							
						<li class="dd-item">
							<a href="/booklet-Scraping/html/Chapters/XPath.html#selecting nodes based on attribute value">Selecting nodes based on attribute value</a>
						</li>
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Scraping/html/Chapters/XPath.html#selecting unknown nodes">
							Selecting Unknown Nodes
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Scraping/html/Chapters/XPath.html#handling multiple queries">
							Handling multiple queries
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item  haschildren ">
					<div>
						<a href="/booklet-Scraping/html/Chapters/XPath.html#xpath axes">
							XPath axes
						</a>
						<i class="fa fa-angle-right fa-lg category-icon"></i>
					</div>

					<ul class="dd-item">
							
						<li class="dd-item">
							<a href="/booklet-Scraping/html/Chapters/XPath.html#paths ">Paths </a>
						</li>
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Scraping/html/Chapters/XPath.html#conclusion">
							Conclusion
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
			  </ul>
		  
		  </li>
		
		  <li class="dd-item  haschildren ">
			<div>
			  <a href="/booklet-Scraping/html/Chapters/Scraping.html#scraping html">
					Scraping HTML
			  </a>
			   <i class="fa fa-angle-right fa-lg category-icon"></i> 
			</div>
			  <ul class="dd-item">
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Scraping/html/Chapters/Scraping.html#getting started">
							Getting started
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Scraping/html/Chapters/Scraping.html#define the problem">
							Define the Problem
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Scraping/html/Chapters/Scraping.html#first find the required data">
							First find the required data
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Scraping/html/Chapters/Scraping.html#going back to our problem">
							Going back to our problem
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Scraping/html/Chapters/Scraping.html#turning the pages">
							Turning the pages
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Scraping/html/Chapters/Scraping.html#conclusion ">
							Conclusion 
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
			  </ul>
		  
		  </li>
		
		  <li class="dd-item  haschildren ">
			<div>
			  <a href="/booklet-Scraping/html/Chapters/Scraping2.html#scraping magic ">
					Scraping Magic 
			  </a>
			   <i class="fa fa-angle-right fa-lg category-icon"></i> 
			</div>
			  <ul class="dd-item">
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Scraping/html/Chapters/Scraping2.html#getting a tree">
							Getting a tree
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item  haschildren ">
					<div>
						<a href="/booklet-Scraping/html/Chapters/Scraping2.html#first the card visual ">
							First the card visual 
						</a>
						<i class="fa fa-angle-right fa-lg category-icon"></i>
					</div>

					<ul class="dd-item">
							
						<li class="dd-item">
							<a href="/booklet-Scraping/html/Chapters/Scraping2.html#no so cool but working... ">No so cool but working... </a>
						</li>
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Scraping/html/Chapters/Scraping2.html#revisiting it">
							Revisiting it
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Scraping/html/Chapters/Scraping2.html#getting data">
							Getting data
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Scraping/html/Chapters/Scraping2.html#conclusion">
							Conclusion
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
			  </ul>
		  
		  </li>
		
    </ul>
  </aside>

  <section class="page">
    
	<h1>Scraping HTML with XPath</h1>
		
	
<p>
I came with the idea of this booklet thank to Peter that kindly answered a question on the Pharo mailing-list. 
To help Peter showed to a Pharoer how to scrap the web site mentioned in Chapter 2 using XPath. In addition, some years ago 
I was maintaining Soup a scraping framework because I want to write an application to manage my magic cards.
Since then I always wanted to try XPath and in addition I wanted to offer this booklet to Peter. Why because I asked Peter 
if he would like to write something and he told that he was at a great age where he would not take any commitment. 
I realised that I would like to get as old as him and be able to hack like a mad in Pharo with new technology. 
So this booklet is a gift to Peter, a great and gentle Pharoer.
I would like to thank Monty the developer of the XML package suite for its great implementation and the feedback on this booklet. 
Stef
</p>

<p>
<h2>Little Journey into XPath</h2>

<p>
XPath is the de factor standard language for navigating an XML document and selecting nodes from it. XPath expressions act as queries that identifies nodes. In this chapter we will go through the main concepts and show some of the ways we can access nodes in a xml document. All the expressions can be executed on the spot, so do not hesitate to experiment with them.
</p>
<h3>Getting started</h3>

<p>
You should load the XML parser and XPath library as follows:
</p><figure><pre><code>Gofer it
   smalltalkhubUser: 'PharoExtras' project: 'XMLParserHTML';
   configurationOf: 'XMLParserHTML';
   loadStable.</code></pre><figcaption></figcaption></figure>

<figure><pre><code>Gofer it
   smalltalkhubUser: 'PharoExtras' project: 'XPath';
   configurationOf: 'XPath';
   loadStable.</code></pre><figcaption></figcaption></figure>


<h3>An example</h3>

<p>
As an example we will take the possible representation of Magic cards, starting with the 
 Arcane Lighthouse that you can view at <a href="http://gatherer.wizards.com/Pages/Card/Details.aspx?multiverseid=389430">http://gatherer.wizards.com/Pages/Card/Details.aspx?multiverseid=389430</a>
and is shown in Figure <a href="#ligthouse"></a>. 
</p>
<p>
<a id="ligthouse"></a>
<figure>
	<img src="Chapters/figures/lighthouse.png" width="100%" id="ligthouse" alt="http://gatherer.wizards.com/Pages/Card/Details.aspx?multiverseid=389430."/>
	<figcaption>http://gatherer.wizards.com/Pages/Card/Details.aspx?multiverseid=389430.</figcaption>
</figure>
</p>
<figure><pre><code>	&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

	&lt;cardset&gt;
	  &lt;card&gt;
	    &lt;cardname lang=&quot;en&quot;&gt;Arcane Lighthouse&lt;/cardname&gt;
	    &lt;types&gt;Land&lt;/types&gt;
	    &lt;year&gt;2014&lt;/year&gt;
		&lt;rarity&gt;Uncommon&lt;/rarity&gt;
		&lt;expansion&gt;Commander 2014&lt;/expansion&gt;
	    &lt;cardtext&gt;Tap: Add 1 uncolor to you mana pool. 
		1 uncolor + Tap: Until end of turn, creatures your opponents
		 control lose hexproof and shroud and can't have 
		 hexproof or shroud.&lt;/cardtext&gt;
	  &lt;/card&gt;
	&lt;/cardset&gt;</code></pre><figcaption></figcaption></figure>

<h3>Creating a tree of objects</h3>

<p>
In Pharo it is always powerful to get an object and interact with it. 
So let us do that now using the <code>XMLDOMParser</code> to convert our data in a tree of objects (as shown in Figure <a href="#inspectorx"></a>).
Note that the escaped the <code>'</code> with an extra quote as in <code>can''t</code>. 
</p>
<figure><pre><code>	| tree |
	tree := (XMLDOMParser on: 
	'&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

	&lt;cardset&gt;
	  &lt;card&gt;
	    &lt;cardname lang=&quot;en&quot;&gt;Arcane Lighthouse&lt;/cardname&gt;
	    &lt;types&gt;Land&lt;/types&gt;
	    &lt;year&gt;2014&lt;/year&gt;
	    &lt;rarity&gt;Uncommon&lt;/rarity&gt;
	    &lt;expansion&gt;Commander 2014&lt;/expansion&gt;
	    &lt;cardtext&gt;Tap: Add 1 uncolor to you mana pool. 
		1 uncolor + Tap: Until end of turn, creatures your opponents
		 control lose hexproof and shroud and can''t have 
		 hexproof or shroud.&lt;/cardtext&gt;
	  &lt;/card&gt;
	&lt;/cardset&gt;') parseDocument</code></pre><figcaption></figcaption></figure>


<p>
<a id="inspectorx"></a>
<figure>
	<img src="Chapters/figures/xpath1.png" width="100%" id="inspectorx" alt="Grabbing and playing with a tree."/>
	<figcaption>Grabbing and playing with a tree.</figcaption>
</figure>
</p>
<h3>Nodes, node sets and atomic values</h3>
<p>
We will be working with three kinds of XPath constructs: nodes, node sets, and atomic values.
</p>
<p>
Node sets are sets (duplicate-free collections) of nodes. All node sets produced by XPath location path expressions are sorted in document order, the order in the document source that they appear in.
</p>
<p>
The following elements are nodes:
</p><figure><pre><code>&lt;cardset&gt; (root element node)

&lt;cardname lang=&quot;en&quot;&gt;Arcane Lighthouse&lt;/cardname&gt; (element node)

lang=&quot;en&quot; (attribute node)</code></pre><figcaption></figcaption></figure>

<p>
Atomic values are strings, numbers, and booleans. Here are some examples of atomic values:
</p>
<figure><pre><code>Arcane Lighthouse
 
&quot;en&quot;

2.5

-1

true

false</code></pre><figcaption></figcaption></figure>


<h3>Basic tree relationships</h3>

<p>
Since we are talking about trees, nodes can have multiple relationships with each other: parent, child and siblings. 
Let us set some simple vocabulary. 
</p>
<ul>
<li><strong>Parent.</strong> Each node can have at most one parent. The root node of the tree, usually a document, has no parent. In the Arcane Lighthouse example, the card element is the parent of the cardname, types, year, rarity, expansion and cardtext elements. In XPath, attribute and namespace nodes treat the element they belong to as their parent.</li>
</ul>

<ul>
<li><strong>Children.</strong> Document and element nodes may have zero, one or more children, which can be elements, text nodes, comments or processing instructions. The cardname, types, year, rarity, expansion and cardtext elements are all children of the card element. Confusingly, even though attribute and namespace nodes can have element parents in XPath, they aren't children of their parent elements.</li>
</ul>

<ul>
<li><strong>Siblings.</strong> Siblings are child nodes that have the same parent. The cardname, types, year, rarity, expansion and cardtext elements are all siblings. Attributes and and namespace nodes have no siblings.</li>
</ul>

<ul>
<li><strong>Ancestors.</strong> A node's parent, parent's parent, etc. Ancestors of the cardname element are the card element and the cardset nodes. </li>
</ul>

<ul>
<li><strong>Descendants</strong> A node's children, children's children, etc. Descendants of the cardset element are the card,cardname, types, year, rarity, expansion and cardtext elements.</li>
</ul>


<h3>A large example</h3>

<p>
Let us expand our example to have cover more cases.
</p>
<figure><pre><code>	
	| tree |
	tree := (XMLDOMParser on: 
	'&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

	&lt;cardset&gt;
	  &lt;card&gt;
	    &lt;cardname lang=&quot;en&quot;&gt;Arcane Lighthouse&lt;/cardname&gt;
	    &lt;types&gt;Land&lt;/types&gt;
	    &lt;year&gt;2014&lt;/year&gt;
	    &lt;rarity&gt;Uncommon&lt;/rarity&gt;
	    &lt;expansion&gt;Commander 2014&lt;/expansion&gt;
	    &lt;cardtext&gt;Tap: Add 1 uncolor to you mana pool. 
		1 uncolor + Tap: Until end of turn, creatures your opponents
		 control lose hexproof and shroud and can''t have 
		 hexproof or shroud.&lt;/cardtext&gt;
	  &lt;/card&gt;
	  &lt;card&gt;
	    &lt;cardname lang=&quot;en&quot;&gt;Desolate Lighthouse&lt;/cardname&gt;
	    &lt;types&gt;Land&lt;/types&gt;
	    &lt;year&gt;2013&lt;/year&gt;
	    &lt;rarity&gt;Rare&lt;/rarity&gt;
	    &lt;expansion&gt;Avacyn Restored&lt;/expansion&gt;
	    &lt;cardtext&gt;Tap: Add Colorless to your mana pool.
	1BlueRed, Tap: Draw a card, then discard a card.&lt;/cardtext&gt;
	  &lt;/card&gt;
	&lt;/cardset&gt;') parseDocument</code></pre><figcaption></figcaption></figure>

<p>
<a id="inspector2"></a>
<figure>
	<img src="Chapters/figures/xpath2.png" width="100%" id="inspector2" alt="Select the raw tab and click on self in the inspector."/>
	<figcaption>Select the raw tab and click on self in the inspector.</figcaption>
</figure>
</p>
<p>
Select the raw tab and click on self in the inspector (as shown in Figure <a href="#inspector2"></a>). Now we are ready to learn XPath.
</p>
<h3>Node selection</h3>

<p>
The following table shows the XPath expressions. Often the current node is also named the context. 
</p>
<table style="border: solid thin"><tr><td><strong>Expression</strong></td>
<td><strong>Description</strong></td>
<td></td>
</tr>
<tr><td>nodename</td>
<td>Selects all child nodes with the name &quot;nodename&quot;</td>
<td></td>
</tr>
<tr><td>/</td>
<td>Selects the root node</td>
<td></td>
</tr>
<tr><td>//</td>
<td>Selects any node from the current node that match the context selection</td>
<td></td>
</tr>
<tr><td>.</td>
<td>Selects the context (current) node</td>
<td></td>
</tr>
<tr><td>..</td>
<td>Selects the parent of the context (current) node</td>
<td></td>
</tr>
<tr><td>@</td>
<td>Selects attributes of the context node</td>
<td></td>
</tr>
</table>


<p>
In the following we expect that the variable <code>tree</code> is bound the full document tree we previously created parsing the XML string.
Location path expressions return node sets, which are empty if no nodes match. Now let us play with the system to really see how it works.
</p>
<h4>Node tag name selection</h4>

<p>
There are several way to test and select nodes.
</p>
<table style="border: solid thin"><tr><td><strong>nodename</strong></td>
<td>Selects all child nodes with the name &quot;nodename&quot;</td>
<td></td>
</tr>
<tr><td>card</td>
<td>Selects all child nodes with the name &quot;card&quot;</td>
<td></td>
</tr>
<tr><td><strong>prefix:localName</strong></td>
<td>Selects all child nodes with the qualified name &quot;prefix:localName&quot;</td>
<td></td>
</tr>
<tr><td></td>
<td>or if at least one prefix/namespace URI pair was declared in the</td>
<td></td>
</tr>
<tr><td></td>
<td>XPathContext, the child nodes with the local name &quot;localName&quot;</td>
<td></td>
</tr>
<tr><td></td>
<td>and the namespace URI bound to &quot;prefix&quot;</td>
<td></td>
</tr>
</table>

<p>
In standard XPath, qualified name tests like prefix:localName select nodes with the same local name and the namespace URI of the prefix, which must be declared in the controlling XPath context prior to evaluation. The selected nodes from the document can have different prefixes (or none at all), because matching is based on local name and namespace URI.
</p>
<p>
To simplify things, the Pharo XPath library (unlike others) by default matches qualified name tests against the literal qualified names of nodes, ignoring namespace URIs completely, and does not require you to pre-declare namespace prefix/URI pairs in the XPathContext object before evaluation. Declaring at least one namespace prefix/URI pair will trigger standard behavior, where all prefixes used in qualified name tests must be pre-declared, and matching will be done based on local names and namespace URIs.
</p>
<h4>Context and parent</h4>

<table style="border: solid thin"><tr><td>.</td>
<td>Selects the current context node</td>
<td></td>
</tr>
<tr><td>..</td>
<td>Selects the parent of the current context node</td>
<td></td>
</tr>
</table>

<p>
The following expression shows that <code>.</code> (period) selects the context node, initially the node XPath evaluation begins in.
</p>
<figure><pre><code>(tree xpath: '.') first == tree
&gt;&gt;&gt; true</code></pre><figcaption></figcaption></figure>



<h4>Matching path-based child nodes</h4>

<p>
The operator <code>/</code> selects from the root node.
</p>
<table style="border: solid thin"><tr><td><strong>/</strong></td>
<td><strong>Selects from the root node</strong></td>
<td></td>
</tr>
<tr><td>/cardset</td>
<td>Selects the root element cardset</td>
<td></td>
</tr>
<tr><td>cardset/card</td>
<td>Selects all the card grandchildren from the cardset children of the context node</td>
<td></td>
</tr>
</table>

<p>
The following expression selects all the card nodes under cardset node.
</p>
<figure><pre><code>path := XPath for: '/cardset/card'.
path in: tree.</code></pre><figcaption></figcaption></figure>

<p>
<code>XPath</code> objects lazily compile their source to an executable form the first time they're evaluated, and the compiled form and its source are cached globally, so caching the <code>XPath</code> object itself in a variable is normally unecessary to avoid recompilation and is only slightly faster. The previous expression is equivalent to the following expression using the <code>xpath:</code> message.
</p>
<figure><pre><code>tree xpath: '/cardset/card'</code></pre><figcaption></figcaption></figure>



<h4>Matching deep nodes</h4>

<p>
The <code>//</code> operation selects all the nodes matching the selection.
</p>

<table style="border: solid thin"><tr><td><strong>//</strong></td>
<td>Selects from the context (current) node and all descendants</td>
<td></td>
</tr>
<tr><td>//year</td>
<td>Selects all year node children of the context node and of its descendants</td>
<td></td>
</tr>
<tr><td>cardset//year</td>
<td>Selects all year node children of the cardset context node children and their descendants</td>
<td></td>
</tr>
</table>

<p>
Let us try with another element such as the expansion of a card. 
</p><figure><pre><code>tree xpath: '//expansion'
&gt;&gt;&gt;
a XPathNodeSet(&lt;expansion&gt;Commander 2014&lt;/expansion&gt; &lt;expansion&gt;Avacyn Restored&lt;/expansion&gt;)</code></pre><figcaption></figcaption></figure>

<p>
The XPath library extends <code>XMLNode</code> classes with binary selectors to encode certain XPath expressions directly in Pharo. So the previous expression can be expressed as follows using the message <code>//</code>:
</p>
<figure><pre><code>tree // 'expansion'
&gt;&gt;&gt;
a XPathNodeSet(&lt;expansion&gt;Commander 2014&lt;/expansion&gt; &lt;expansion&gt;Avacyn Restored&lt;/expansion&gt;)</code></pre><figcaption></figcaption></figure>


<h4>Identifying attributes</h4>

<p>
<code>@</code> matches attributes. 
</p>
<table style="border: solid thin"><tr><td><strong>Expression</strong></td>
<td><strong>Description</strong></td>
<td></td>
</tr>
<tr><td>@</td>
<td>Selects attributes</td>
<td></td>
</tr>
<tr><td>//@lang</td>
<td>Selects all attributes that are named lang</td>
<td></td>
</tr>
</table>
<p>
 
</p>

<p>
The following expression returns all the attributes whose name is <code>lang</code>.
</p><figure><pre><code>(tree xpath: '//@lang') 
&gt;&gt;&gt;  a XPathNodeSet(lang=&quot;&quot;en&quot;&quot; lang=&quot;&quot;en&quot;&quot;)</code></pre><figcaption></figcaption></figure>



<h3>Predicates</h3>

<p>
Predicates are used to find a specific node or a node that contains a specific value. Predicates are always embedded in square brackets.
</p>
<p>
Let us study some examples:
</p>
<h4>First element</h4>

<p>
The following expression selects the first card child of the cardset element.
</p><figure><pre><code>tree xpath: '/cardset/card[1]'
&gt;&gt;&gt;
a XPathNodeSet(&lt;card&gt;
    &lt;cardname lang=&quot;&quot;en&quot;&quot;&gt;Arcane Lighthouse&lt;/cardname&gt;
    &lt;types&gt;Land&lt;/types&gt;
    &lt;year&gt;2014&lt;/year&gt;
    &lt;rarity&gt;Uncommon&lt;/rarity&gt;
    &lt;expansion&gt;Commander 2014&lt;/expansion&gt;
    &lt;cardtext&gt;Tap: Add 1 uncolor to you mana pool. 
	1 uncolor + Tap: Until end of turn, creatures your opponents
	 control lose hexproof and shroud and can't have 
	 hexproof or shroud.&lt;/cardtext&gt;
  &lt;/card&gt;)</code></pre><figcaption></figcaption></figure>

<p>
In the XPath Pharo implementation, the message <code>??</code> can be used for position or block predicates.
</p>
<p>
the previous expression is equivalent to the following one
</p>
<figure><pre><code>tree / 'cardset' / ('card' ?? 1) .</code></pre><figcaption></figcaption></figure>


<p>
Block or position predicates can be applied with <code>??</code> to axis node test arguments or to result node sets. 
</p>
<p>
The following expression returns the first element of each 'card' descendant:
</p>
<figure><pre><code>tree // 'card' / ('*' ?? 1)
&gt;&gt;&gt; &quot;a XPathNodeSet(&lt;cardname lang=&quot;&quot;en&quot;&quot;&gt;Arcane Lighthouse&lt;/cardname&gt; &lt;cardname lang=&quot;&quot;en&quot;&quot;&gt;Desolate Lighthouse&lt;/cardname&gt;)&quot;</code></pre><figcaption></figcaption></figure>

<h4>Other position functions</h4>

<p>
The following expression selects the last card node that is the child of the cardset node.
</p>
<figure><pre><code>tree xpath: '/cardset/card[last()]'.</code></pre><figcaption></figcaption></figure>

<p>
The following selects the second to last node. In our case since we only have two elements we get the first. 
</p>
<figure><pre><code>tree xpath: '/cardset/card[last()-1]'.
&gt;&gt;&gt;
a XPathNodeSet(&lt;card&gt;
	    &lt;cardname lang=&quot;&quot;en&quot;&quot;&gt;Arcane Lighthouse&lt;/cardname&gt;
	    &lt;types&gt;Land&lt;/types&gt;
	    &lt;year&gt;2014&lt;/year&gt;
	    &lt;rarity&gt;Uncommon&lt;/rarity&gt;
	    &lt;expansion&gt;Commander 2014&lt;/expansion&gt;
	    &lt;cardtext&gt;Tap: Add 1 uncolor to you mana pool. 
		1 uncolor + Tap: Until end of turn, creatures your opponents
		 control lose hexproof and shroud and can't have 
		 hexproof or shroud.&lt;/cardtext&gt;
	  &lt;/card&gt;)</code></pre><figcaption></figcaption></figure>

<p>
We can also use the position function and use it to identify nodes. The following selects the first two card nodes that are children of the cardset node. 
</p>
<figure><pre><code>(tree xpath: '/cardset/card[position()&lt;3]') size = 2
&gt;&gt;&gt; true</code></pre><figcaption></figcaption></figure>


<h4>Selecting based on node value</h4>

<p>
In addition we can select nodes based on a value of a node. The following query selects all the card nodes (of the cardset) that have a year greater than 2014.
</p>
<figure><pre><code>tree xpath: '/cardset/card[year&gt;2013]'.</code></pre><figcaption></figcaption></figure>

<p>
The following query selects all the cardname nodes of the card children of cardset that have a year greater than 2014.
</p>
<figure><pre><code>/cardset/card[year&gt;2013]/cardname
&gt;&gt;&gt; a XPathNodeSet(&lt;cardname lang=&quot;&quot;en&quot;&quot;&gt;Arcane Lighthouse&lt;/cardname&gt;)</code></pre><figcaption></figcaption></figure>

<h4>Selecting nodes based on attribute value</h4>

<p>
We can also select nodes based on the existence or value of an attribute.
The following expression returns the cardname that have the lang attribute and whose value is 'en'.
</p><figure><pre><code>tree xpath: '//cardname[@lang]
&gt;&gt;&gt; a XPathNodeSet(&lt;cardname lang=&quot;&quot;en&quot;&quot;&gt;Arcane Lighthouse&lt;/cardname&gt; &lt;cardname lang=&quot;&quot;en&quot;&quot;&gt;Desolate Lighthouse&lt;/cardname&gt;)
tree xpath: '//cardname[@lang='en']</code></pre><figcaption></figcaption></figure>

<p>
Note that we can simply get the card from the name using '..'.
</p>
<figure><pre><code>tree xpath: '//cardname[@lang='en']/..
&gt;&gt;&gt;</code></pre><figcaption></figcaption></figure>

<h3>Selecting Unknown Nodes</h3>

<p>
In addition we can use wildcard to select any node. 
</p>
<table style="border: solid thin"><tr><td><strong>Wildcard</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr><td>*</td>
<td>Matches any element node</td>
<td></td>
</tr>
<tr><td>@*</td>
<td>Matches any attribute node</td>
<td></td>
</tr>
<tr><td>node()</td>
<td>Matches any node of any kind</td>
<td></td>
</tr>
</table>

<p>
For example <code>//*</code> selects all elements in a document. 
</p>
<figure><pre><code>(tree xpath: '//*') size
&gt;&gt;&gt; 15</code></pre><figcaption></figcaption></figure>

<p>
While <code>//@*</code> selects all the attributes of any node. 
</p>
<figure><pre><code>tree xpath: '//@*'
&gt;&gt;&gt; a XPathNodeSet(lang=&quot;&quot;en&quot;&quot; lang=&quot;&quot;en&quot;&quot;)</code></pre><figcaption></figcaption></figure>

<p>
For example <code>//cardname[@*]</code> selects all cardname elements which have at least one attribute of any kind.
</p><figure><pre><code>tree xpath: '//cardname[@*]'
&gt;&gt;&gt; a XPathNodeSet(&lt;cardname lang=&quot;&quot;en&quot;&quot;&gt;Arcane Lighthouse&lt;/cardname&gt; &lt;cardname lang=&quot;&quot;en&quot;&quot;&gt;Desolate Lighthouse&lt;/cardname&gt;)</code></pre><figcaption></figcaption></figure>
<p>
The following expression selects all child nodes of cardset.
</p><figure><pre><code>tree xpath: '/cardset/*'.</code></pre><figcaption></figcaption></figure>

<p>
The following expression selects all the cardname of all the child nodes of cardset. 
</p><figure><pre><code>tree xpath: '/cardset/*/cardname'.</code></pre><figcaption></figcaption></figure>

<h3>Handling multiple queries</h3>

<p>
By using the <code>|</code> union operator in an XPath expression you can select several paths.
The following expression selects both the cardname and year of card nodes located anywhere in the document. 
</p>
<figure><pre><code>tree xpath: '//card/cardname | //card//year'
&gt;&gt;&gt; a XPathNodeSet(&lt;cardname lang=&quot;&quot;en&quot;&quot;&gt;Arcane Lighthouse&lt;/cardname&gt; &lt;year&gt;2014&lt;/year&gt; 
&lt;cardname lang=&quot;&quot;en&quot;&quot;&gt;Desolate Lighthouse&lt;/cardname&gt; &lt;year&gt;2013&lt;/year&gt;)&quot;</code></pre><figcaption></figcaption></figure>

<h3>XPath axes</h3>

<p>
XPath introduces another way to select nodes using <em>location step</em> following the syntax: <code>axisname::nodetest[predicate]</code>.
Such expressions can be used in the steps of location paths (see below). 
</p>
<p>
An axis defines a node-set relative to the context (current) node. Here is a table of the available axes. 
Except for the namespace axis, all of these have binary selector equivalents.
</p>
<table style="border: solid thin"><tr><td><strong>AxisName</strong></td>
<td><strong>Result</strong></td>
</tr>
<tr><td>ancestor</td>
<td>Selects all context (current) node ancestors</td>
</tr>
<tr><td>ancestor-or-self</td>
<td>... and the context node itself</td>
</tr>
<tr><td>attribute</td>
<td>Selects all context (current) node attributes</td>
</tr>
<tr><td>child</td>
<td>Selects all context (current) node children</td>
</tr>
<tr><td>descendant</td>
<td>Selects all context node descendants</td>
</tr>
<tr><td>descendant-or-self</td>
<td>... and the context node itself</td>
</tr>
<tr><td>following</td>
<td>Selects everything after the context node closing tag</td>
</tr>
<tr><td>following-sibling</td>
<td>Selects all siblings after the context node</td>
</tr>
<tr><td>namespace</td>
<td>Selects all context node namespace nodes</td>
</tr>
<tr><td>parent</td>
<td>Selects context node parent</td>
</tr>
<tr><td>preceding</td>
<td>Selects all nodes that appear before the context node</td>
</tr>
<tr><td></td>
<td>except ancestors, attribute nodes and namespace nodes</td>
</tr>
<tr><td>preceding-sibling</td>
<td>Selects all siblings before the context node</td>
</tr>
<tr><td>self</td>
<td>Selects the context node</td>
</tr>
</table>


<h4>Paths </h4>

<p>
A location path can be absolute or relative. An absolute location path starts with a slash ( / ) (/step/step/...) and a relative location path does not (step/step/...). In both cases the location path consists of one or more location steps, each separated by a slash.
</p>
<p>
Each step is evaluated against the nodes in the context node-set.
A location step, <code>axisname::nodetest[predicate]</code>,  consists of:
</p><ul>
<li>an axis (defines the tree-relationship between the selected nodes and the context node)</li>
<li>a node-test (identifies a node within an axis)</li>
<li>zero or more predicates (to further refine the selected node-set)</li>
</ul>

<p>
The following example access the year node of all the children of the cardset. 
</p><figure><pre><code>tree xpath: '/cardset/child::node()/year').
&gt;&gt;&gt;a XPathNodeSet(&lt;year&gt;2014&lt;/year&gt; &lt;year&gt;2013&lt;/year&gt;)</code></pre><figcaption></figcaption></figure>

<p>
The following expression gets the ancestor of the year node and selects the cardname.
</p><figure><pre><code>(tree xpath: '/cardset/card/year') first  xpath: 'ancestor::card/cardname'
&gt;&gt;&gt; &quot;a XPathNodeSet(&lt;cardname lang=&quot;&quot;en&quot;&quot;&gt;Arcane Lighthouse&lt;/cardname&gt;)&quot;</code></pre><figcaption></figcaption></figure>

<p>
The previous expression could be rewritten using a position predicate. Parentheses are needed so the predicate applies to the entire node set produced by the absolute location path, rather than just the last step, otherwise it would select the first year of each card, instead of the first year overall:
</p><figure><pre><code>(tree xpath: '(/cardset/card/year)[1]/ancestor::card/cardname'
&gt;&gt;&gt; &quot;a XPathNodeSet(&lt;cardname lang=&quot;&quot;en&quot;&quot;&gt;Arcane Lighthouse&lt;/cardname&gt;)&quot;</code></pre><figcaption></figcaption></figure>






<h3>Conclusion</h3>

<p>
XPath is a powerful language. The Pharo XPath library developed and maintained by Monty van OS and the Pharo Extras Team  implements the full standard 1.0. Coupled with the live programming capabilities of Pharo, it gives a really powerful way to explore structured XML data. 
</p>




<h2>Scraping HTML</h2>

<p>
Internet pages provide a lot of information and often you would like to be able to access and manipulate it in another form than HTML: HTML is just plain verbose. What you would like is to get access to only the information you are interested in and get the results in a form that you can easily build more software. This is the objective of HTML scraping. In Pharo you can scrape web pages using different libraries such as XMLParser and SOUP. 
In this chapter we will show you how we can do that using XMLParser to locate and collect the data we need and JSON to format and output the information. 
</p>
<p>
This chapter has been originally written by Peter Kenny and we thank him for sharing with the community this little tutorial. 
</p>
<h3>Getting started</h3>
<p>
You can use the Catalog browser to load XMLParserHTML and NeoJSON just execute the following expressions: 
</p>
<figure><pre><code>Gofer it
   smalltalkhubUser: 'PharoExtras' project: 'XMLParserHTML';
   configurationOf: 'XMLParserHTML';
   loadStable.</code></pre><figcaption></figcaption></figure>

<figure><pre><code>Gofer it
   smalltalkhubUser: 'PharoExtras' project: 'XPath';
   configurationOf: 'XPath';
   loadStable.</code></pre><figcaption></figcaption></figure>

<figure><pre><code>Gofer it
   smalltalkhubUser: 'SvenVanCaekenberghe' project: 'Neo';
   configurationOf: 'NeoJSON';
   loadStable.</code></pre><figcaption></figcaption></figure>




<h3>Define the Problem</h3>
<p>
This tutorial is based on a real life problem. We need to consult a database published by the US Department of Agriculture, extract data for over 8000 food ingredients and their nutrient contents and output the results as a JSON file. The main list of ingredients can be found at the following url: <a href="https://ndb.nal.usda.gov/ndb/search/list?sort=ndb&ds=Standard+Reference">https://ndb.nal.usda.gov/ndb/search/list?sort=ndb&ds=Standard+Reference</a> (as shown in Figure <a href="#figfood"></a>). You can also find the HTML version of the file in the github repository of this book <a href="https://github.com/SquareBracketAssociates/Booklet-Scraping/resources">https://github.com/SquareBracketAssociates/Booklet-Scraping/resources</a>.
</p>
<p>
<a id="figfood"></a>
<figure>
	<img src="Chapters/figures/food.png" width="100%" id="figfood" alt="Food list."/>
	<figcaption>Food list.</figcaption>
</figure>
</p>
<p>
This table shows the first 50 rows, each corresponding to an ingredient. The table shows the NDB number, description and food group for each ingredient. Clicking on the number or description leads to a detailed table for the ingredient. This table comes in two forms, basic details and full details, and the information we want is in the full details. The full detailed table for the first ingredient can be found at the url:
<a href="https://ndb.nal.usda.gov/ndb/foods/show/1?format=Full">https://ndb.nal.usda.gov/ndb/foods/show/1?format=Full</a> (as shown in Figure <a href="#figfood2"></a>).
</p>

<p>
<a id="figfood2"></a>
<figure>
	<img src="Chapters/figures/food2.png" width="100%" id="figfood2" alt="Food details - Salted Butter."/>
	<figcaption>Food details - Salted Butter.</figcaption>
</figure>
</p>

<p>
There are two areas of information that need to be extracted from this detailed table:
</p><ul>
<li>There is a row of special factors, in this case beginning with 'Carbohydrate Factor: 3.87'. This is to be extracted as a set of (name, value) pairs. The number of factors can vary; some ingredients do not have any.</li>
<li>There is a table of data for various nutrients, which are arranged in groups - proximates, vitamins, lipids etc. The number of columns in the table varies from one ingredient to another, but in every case the first three columns are nutrient name, unit of measurement and quantity; we have to extract these columns for every listed nutrient.</li>
</ul>

<p>
The requirement is to extract all this information for each ingredient, and then output it as a JSON file:
</p><ul>
<li>NBD number, description and food group from the main list;</li>
<li>Factor names and values from the detailed table;</li>
<li>Nutrient details from the detailed table.</li>
</ul>


<h3>First find the required data</h3>
<p>
To start, we have to find where the required data are to be found in the HTML file. The general rule about this is that there are no rules. Web site designers are concerned only with the visual effect of the page, and they can use any of the many tricks of HTML to produce the desired effects. We use the XML HTML parser to convert text into an XML tree (a tree whose nodes are XML objects). We then explore this tree to find the elements we want, and for each one we have to find signposts showing a route through the tree to uniquely locate the element, using a combination of XPath and Smalltalk programming as required. We may use the names or attributes of the HTML tags, each of which becomes an instance of XMLElement in the tree, or we may match against the text content of a node.
</p>
<p>
First read in the table of ingredients (first 50 rows only) as in the url. 
</p>
<figure><pre><code>| ingredientsXML |
ingredientsXML := XMLHTMLParser parseURL: 'https://ndb.nal.usda.gov/ndb/search/list?sort=ndb&amp;ds=Standard+Reference'.
ingredientsXML inspect</code></pre><figcaption></figcaption></figure>


<p>
You can execute the expression and inspect its result. You will obtain an inspector on the tree and you can navigate this tree as shown in Figure <a href="#inspector1"></a>. 
</p>
<p>
<a id="inspector1"></a>
<figure>
	<img src="Chapters/figures/InspectorXML.png" width="100%" id="inspector1" alt="Navigating the XML document inside the inspector."/>
	<figcaption>Navigating the XML document inside the inspector.</figcaption>
</figure>
</p>
<p>
Since you may want to work on files that you saved on your disc you can also parse a file and get an XML tree as follows:
</p>
<figure><pre><code>| ingredientsXML |
ingredientsXML := (XMLHTMLParser onFileNamed: 'FoodsList.html') parseDocument.</code></pre><figcaption></figcaption></figure>

<p>
The simplest way to explore the tree is starting from the top, i.e. by opening up the <code>&lt;body&gt;</code> node, but this can be tedious and confusing; we often find that there are many levels of nested <code>&lt;div&gt;</code> nodes before finding what we want. Alternatively, we can use XPath speculatively to look for interesting nodes. In the case of the foods list, we might guess that the list of ingredients will be stored in a <code>&lt;table&gt;</code> node. Having parsed the web page as shown above in a playground, we can then enter:
</p><figure><pre><code>ingredientsXML xPath: '//table'</code></pre><figcaption></figcaption></figure>
<p>
and select 'do it and go', which shows an <code>XMLNodeList</code> of all the table nodes - only one in this case. If there were several, we could use the attributes of the node or any of its ancestors to locate the one we want. We find by searching up several generations a node <code>&lt;div class=&quot;wbox&quot;&gt;</code> which is unique, so we could use this as a signpost. The table body contains a row for each ingredient; the first cell in the row is a &quot;badge&quot; which is of no interest, but the remaining three cells in the row are the number, description and group name that we want. The second and third cells both contain an emebedded node <code>&lt;a href=&quot;....&quot;&gt;</code> showing the relative url of the associated detail table.
</p>
<p>
The exploration of the detail table proceeds in a similar way; we search for text nodes which contain the word &quot;Factor&quot;, and then for a table containing the nutrient details. More of this below.
</p>



<h3>Going back to our problem</h3>
<p>
Here we present the essential points of the data scraping and JSON output for one item, in a logical order. The code is presented as it could be entered in a playground. There are brief comments on the format of the data and the signposts used to locate it. First read in the table of ingredients (first 50 rows only) as before.
</p>
<figure><pre><code>ingredientsXML := XMLHTMLParser parseURL: 'https://ndb.nal.usda.gov/ndb/search/list?sort=ndb&amp;ds=Standard+Reference'.</code></pre><figcaption></figcaption></figure>

<p>
The detail rows are in the body of the table in the div node whose class is 'wbox'.
</p>
<figure><pre><code>ingredientRows := (ingredientsXML xPath: '//div[@class=''wbox'']//tbody/tr').</code></pre><figcaption></figcaption></figure>
<p>
 
Note that the signposts do not need to show every step of the way, provided the route is unique; we do not need to mention the <code>&lt;table&gt;</code> node, because there is only one <code>&lt;tbody&gt;</code>. Now extract the text content of the four cells in each row; 'strings first' is a convenient way of finding the text in a node while ignoring any descendent nodes, and we routinely trim redundant spaces.
</p><figure><pre><code>ingredientCells := ingredientRows collect: 
               [:row| (row xPath: 'td') collect: 
                              [ :cell| cell strings first trim]].</code></pre><figcaption></figcaption></figure>

<p>
To prepare for export to JSON, it is handy to put the three required fields (ignoring the first) in a Dictionary indexed by their field names. Using an OrderedDictionary is not strictly necessary, but it does mean that the JSON output is easier for a human to understand.
</p>
<figure><pre><code>ingredientsJSON := ingredientCells collect: 
               [ :row| { 'nbd_no' -&gt; (row at: 2). 
                              'full-name' -&gt; (row at: 3). 
                              'food-group' -&gt; (row at: 4)} 
asOrderedDictionary ].</code></pre><figcaption></figcaption></figure>
<p>
 
If we 'do it and go' the next line, we can see the JSON layout. For this demo, we do not need to export to a JSON file; it is easier to look at it as text in the playground.
</p>
<figure><pre><code>NeoJSONWriter toStringPretty: ingredientsJSON first.</code></pre><figcaption></figcaption></figure>

<p>
We can find the relative url address of the ingredient details from the href in the second cell. Because this is the address of the basic details table, we edit it to discard all the parameters, so that we can edit in the parameters for the full table.
</p><figure><pre><code>ingredientAddress := ingredientRows collect: 
               [ :row| (row xPath:'td[2]/a/@href') first value copyUpTo: $?].</code></pre><figcaption></figcaption></figure>

<p>
Up to this point, we have been constructing lists with data for all 50 ingredients in the table. To show how to process the ingredient details, we just process the first ingredient in the file. The production version would have to run through all the rows in the ingredientAddress collection. We read and parse the detail file, after editing the url.
</p>
<figure><pre><code>ingredientDetailsXML := XMLHTMLParser parseURL: 'https://ndb.nal.usda.gov', ingredientAddress first, '?format=Full'.</code></pre><figcaption></figcaption></figure>

<p>
The data for the factors are contained in <code>&lt;span&gt;</code> nodes within <code>&lt;div class=&quot;row&quot;&gt;</code> nodes. This does not identify them uniquely, so we extract all such nodes with XPath and then use ordinary Smalltalk to find the ones mentioning the word 'Factor'.
</p>
<figure><pre><code>factorCells := (ingredientDetailsXML xPath: '//div[@class=''row'']//span') 
			collect: [:each| each strings first trim].

factors := OrderedCollection new.
1 to: factorCells size by: 2 do: [ :index|
	((factorCells at: index) matches: 'Factor') ifTrue: [factors addLast: 
		{'factor' -&gt; (factorCells at: index). 
		'amt' -&gt; ((factorCells at: index + 1) trimRight:[:c|c asInteger = 160])} 
		asOrderedDictionary]].</code></pre><figcaption></figcaption></figure>

<p>
Note: it appears that the web designers have used no-break space characters to control the formatting, and these are not removed by 'trim', so we use the 'trimRight:' clause above to remove them.
</p>
<p>
The layout of the nutrients table is messy, presumably to achieve the effect of the inserted row with the nutrient group name. This means that we cannot locate the nutrient rows using <code>&lt;tr&gt;</code> nodes, as we did for the main list. Instead we have to get at all the individual table cells in <code>&lt;td&gt;</code> nodes, and then count them in groups equal to the row length. Since the row length is not a constant, we have to determine it by examining the data for one row that <a href="Chapters/is"></a> in a <code>&lt;tr&gt;</code> node.
</p>
<figure><pre><code>nutrientCells := (ingredientDetailsXML xPath: '//table//td') collect: [:each|each strings first trim].

nutRowLength := (ingredientDetailsXML xPath: '//table/tbody/tr') first elements size.

nutrients := OrderedCollection new.
1 to: nutrientCells size by: nutRowLength do: 
[:index|nutrients addLast: 
	{ 'group' -&gt; (nutrientCells at: index). 
	'nutrient' -&gt; (nutrientCells at: index + 1). 
	'unit' -&gt; (nutrientCells at: index + 2). 
	'per100g' -&gt; (nutrientCells at: index + 3) } 
	asOrderedDictionary ].</code></pre><figcaption></figcaption></figure>

<p>
Finally assemble all the information for the first ingredient as a JSON file. NeoJSON automatically takes care of embedding dictionaries within a collection within a dictionary. (See specimen in Figure <a href="#jsonspec"></a>)
</p>
<figure><pre><code>NeoJSONWriter toStringPretty: 
	((ingredientsJSON first) 
		at: 'factors' put: factors asArray; 
		at: 'nutrients' put: nutrients asArray; 
		yourself).</code></pre><figcaption></figcaption></figure>

<p>
<a id="jsonspec"></a>
<figure>
	<img src="Chapters/figures/JSON_Sample.png" width="100%" id="jsonspec" alt="Sample of JSON output."/>
	<figcaption>Sample of JSON output.</figcaption>
</figure>
</p>
<h3>Turning the pages</h3>
<p>
The code above will extract the data for one ingredient, and could obviously be repeated for all the 50 items in one page of data. However, the entire database contains 8789 ingredients at the time of writing, which amounts to 176 pages. The database seems to impose a limit of 50 ingredients per page, so to process the entire database we need to read the pages in succession. Each page contains a link which, if clicked, will load the next page. We can do this programmatically, by finding the link after processing the page. The link is contained in node <code>&lt;div class=&quot;paginateButtons&quot;&gt;</code>, so we can use the code:
</p>
<figure><pre><code>nextButtons := (ingredientsXML xPath: '//div[@class=''paginateButtons'']//a')
			 select:[:node| node strings first = 'Next'].

nextURL := (nextButtons size &gt; 0) 
			ifTrue:['https://ndb.nal.usda.gov', (nextButtons first attributeAt: 'href')] 
			ifFalse: [nil].</code></pre><figcaption></figcaption></figure>

<p>
This is a common requirement in processing large databases on the web, and so we can use a standard pattern:
</p>
<figure><pre><code>&lt;code to initialise results&gt;
nextURL := &lt;url for first page of database&gt;
[nextURL isNil] whileFalse:
[pageXML := XMLHTMLParser parseURL: nextURL.
&lt;code to extract data from pageXML to results&gt;
&lt;code to determine nextURL from pageXML; should yield 'nil' for last page&gt;
]</code></pre><figcaption></figcaption></figure>

<h3>Conclusion </h3>

<p>
We have presented a way to extract information from a structured document. The methods used are of course particular to the layout of the USDA database, but the general principles should be clear. A mixture of XPath and Smalltalk can be used in order to locate the required data.
</p>
<p>
One problem which can arise, if we need to repeat the extraction with updated data, is that the web designers can change the layout of the pages; this did in fact happen with the USDA table in the 15 months between originally tackling the problem and writing this article. The usual result is that the signposts no longer work, and the XPath results are empty. If the update is being run automatically, say on a daily basis, it may be worth while inserting defensive code in the processing, which will raise an exception if the results are not as expected. How to do this will depend on the particular application.

</p>
<h2>Scraping Magic </h2>

<p>
In this chapter we will scrap the web site of Magic the gathering and in particular the card database. (Yes I play Magic not super good but well I have fun). 
Here is one example <a href="http://gatherer.wizards.com/Pages/Card/Details.aspx?multiverseid=389430">http://gatherer.wizards.com/Pages/Card/Details.aspx?multiverseid=389430</a>  as shown in Figure <a href="#ligthouse2"></a>.
Now we will try to show you how we explore the HTML page using the excellent Pharo inspector: diving in the tree nodes and checking live their attributes or children is simply super cool.
</p>

<p>
<a id="ligthouse2"></a>
<figure>
	<img src="Chapters/figures/arcane.png" width="80%" id="ligthouse2" alt="http://gatherer.wizards.com/Pages/Card/Details.aspx?multiverseid=389430."/>
	<figcaption>http://gatherer.wizards.com/Pages/Card/Details.aspx?multiverseid=389430.</figcaption>
</figure>
</p>
<h3>Getting a tree</h3>

<p>
The first thing was to make sure that we can get a tree from the web page. For this task we used the <code>XMLHTMLParser</code> class and sends it the message <code>parseURL:</code>. How did we find this message... Simply looking on the class side methods of the class. 
How did we find the class, well looking at the subclass of <code>XMLDOMParser</code> because HTML is close to XML or the inverse :).  
</p>
<figure><pre><code>| tree |
tree := (XMLHTMLParser parseURL: 'http://gatherer.wizards.com/Pages/Card/Details.aspx?multiverseid=389430') </code></pre><figcaption></figcaption></figure>



<h3>First the card visual </h3>

<p>
First we would like to grab the card visual because this is fun and cool. When we open the card visual in a separate window we see that the url is <a href="http://gatherer.wizards.com/Handlers/Image.ashx?multiverseid=389430&type=card">http://gatherer.wizards.com/Handlers/Image.ashx?multiverseid=389430&type=card</a>. Therefore we started to look for Handlers in the nodes as shown in Figure <a href="#image0"></a>.
</p>

<p>
<a id="image0"></a>
<figure>
	<img src="Chapters/figures/magic1.png" width="80%" id="image0" alt="Exploring images."/>
	<figcaption>Exploring images.</figcaption>
</figure>
</p>
<figure><pre><code>| tree |
tree := (XMLHTMLParser parseURL: 'http://gatherer.wizards.com/Pages/Card/Details.aspx?multiverseid=389430').
tree xpath: '//img'	</code></pre><figcaption></figcaption></figure>



<h4>No so cool but working... </h4>

<p>
Toying with the inspector, we come up with the following ugly expression to get the name of the JPEG
</p>
<figure><pre><code>| tree |
tree := (XMLHTMLParser parseURL: 'http://gatherer.wizards.com/Pages/Card/Details.aspx?multiverseid=389430').
((tree xpath: '//img') third @ 'src') first value allButFirst: 5
&gt;&gt;&gt; 'Handlers/Image.ashx?multiverseid=389430&amp;type=card'</code></pre><figcaption></figcaption></figure>

<p>
Ugly isn't it? This happens often when scraping HTML, but we can do better. 
By the way note also that we start to enter directly XPath command using the XPath pane and using the doit and go facilities of the inspector. 
This way we do not have to get the page from internet all the time. 
</p>

<h3>Revisiting it</h3>

<p>
We could not really show you such ugly expressions so we had to find a better one.
</p>
<p>
So first we look at the img that has src as atttribute as shown below and in Figure <a href="#image1"></a>.
</p><figure><pre><code>| tree |
tree := (XMLHTMLParser parseURL: 'http://gatherer.wizards.com/Pages/Card/Details.aspx?multiverseid=389430').
(tree xpath: '//img[@src]')</code></pre><figcaption></figcaption></figure>

<p>
<a id="image1"></a>
<figure>
	<img src="Chapters/figures/magic2.png" width="80%" id="image1" alt="Exploring images."/>
	<figcaption>Exploring images.</figcaption>
</figure>
</p>
<p>
Then as shown in Figure <a href="#image2"></a> we inspected the right node.
 
<a id="image2"></a>
<figure>
	<img src="Chapters/figures/magic3.png" width="80%" id="image2" alt="Narrowing the node."/>
	<figcaption>Narrowing the node.</figcaption>
</figure>
</p>
<p>
Finally since we were on this exact node, we looked in its class to see if we could get an API to get the attribute in a nice way as shown in Figure <a href="#image3"></a>.
</p>
<p>
<a id="image3"></a>
<figure>
	<img src="Chapters/figures/magic4.png" width="80%" id="image3" alt="Exploring the class API on the spot: looking to see if there is a attribute something method."/>
	<figcaption>Exploring the class API on the spot: looking to see if there is a attribute something method.</figcaption>
</figure>
</p>
<figure><pre><code>| tree |
tree := (XMLHTMLParser parseURL: 'http://gatherer.wizards.com/Pages/Card/Details.aspx?multiverseid=389430').
(tree xpath: '//img[@src]') third attributeAt: 'src'</code></pre><figcaption></figcaption></figure>

<p>
Now that we have the visual path, we can use the HTTP client of Pharo to get the image as shown in Figure <a href="#zinc"></a>.
</p>
<figure><pre><code>| tree path |
tree := (XMLHTMLParser parseURL: 'http://gatherer.wizards.com/Pages/Card/Details.aspx?multiverseid=389430').
path := ((tree xpath: '//img[@src]')	third attributeAt: 'src') allButFirst: 5.
(ZnEasy getJpeg: 'http://gatherer.wizards.com/',path) asMorph openInWorld</code></pre><figcaption></figcaption></figure>

<p>
<a id="zinc"></a>
<figure>
	<img src="Chapters/figures/magic5.png" width="100%" id="zinc" alt="Getting the card visual inside Pharo."/>
	<figcaption>Getting the card visual inside Pharo.</figcaption>
</figure>
</p>
<h3>Getting data</h3>

<p>
Since this web page is probably generated, we look for example for the artist string in the source and we found the following matches:
</p>
<figure><pre><code>ClientIDs.artistRow = 'ctl00_ctl00_ctl00_MainContent_SubContent_SubContent_artistRow';</code></pre><figcaption></figcaption></figure>

<p>
This one is more interesting:
</p>
<figure><pre><code>&lt;div id=&quot;ctl00_ctl00_ctl00_MainContent_SubContent_SubContent_artistRow&quot; class=&quot;row&quot;&gt;
   &lt;div class=&quot;label&quot;&gt;
       Artist:&lt;/div&gt;
   &lt;div id=&quot;ctl00_ctl00_ctl00_MainContent_SubContent_SubContent_ArtistCredit&quot; class=&quot;value&quot;&gt;
     &lt;a href=&quot;/Pages/Search/Default.aspx?action=advanced&amp;amp;artist=[%22Igor Kieryluk%22]&quot;&gt;Igor Kieryluk&lt;/a&gt;&lt;/div&gt;</code></pre><figcaption></figcaption></figure>

<p>
We can build queries to identify node elements having this id.
To avoid to perform an internet request each time, we typed directly XPath path in the XPath pane of the inspector as shown in Figure <a href="#row"></a>.
Now trying to get faster we looked at all the class=&quot;row&quot; as shown in Figure <a href="#row"></a>.
</p>
<figure><pre><code>//div[@class='row']</code></pre><figcaption></figcaption></figure>

<p>
<a id="row"></a>
<figure>
	<img src="Chapters/figures/magic6.png" width="80%" id="row" alt="Getting the card information."/>
	<figcaption>Getting the card information.</figcaption>
</figure>
</p>
<p>
The following expression returns the pair label and value for example for the card name label and its value.
</p>
<figure><pre><code>//div[@class='row']/div[@class='label']| //div[@class='row']/div[@class='value']</code></pre><figcaption></figcaption></figure>

<p>
So we can now query all the fields
</p>
<figure><pre><code>| tree |
tree := (XMLHTMLParser parseURL: 'http://gatherer.wizards.com/Pages/Card/Details.aspx?multiverseid=389430').
container := tree xpath: '//div[@class=''row'']/div[@class=''label'']| //div[@class=''row'']/div[@class=''value'']'.
container collect: [ :each | each contentString trimBoth  ].
&gt;&gt;&gt; a XMLOrderedList('Card Name:' 'Arcane Lighthouse' 'Types:' 'Land' 'Card Text:' 
': Add  to your mana pool. , : Until end of turn, creatures your opponents control 
lose hexproof and shroud and can''t have hexproof or shroud.' 
'Expansion:' 'Commander 2014' 'Rarity:' 'Uncommon' 'Card Number:' '59' 'Artist:' 'Igor Kieryluk')</code></pre><figcaption></figcaption></figure>

<p>
Now we can convert this into a dictionary 
</p>
<figure><pre><code>| tree  |
tree := (XMLHTMLParser parseURL: 'http://gatherer.wizards.com/Pages/Card/Details.aspx?multiverseid=389430').
container := tree xpath: '//div[@class=''row'']/div[@class=''label'']| //div[@class=''row'']/div[@class=''value'']'.
((container collect: [ :each | each contentString trimBoth  ])
	asOrderedCollection groupsOf: 2 atATimeCollect: [ :x :y | x -&gt; y]) asDictionary</code></pre><figcaption></figcaption></figure>


<p>
And convert it into JSON for fun
</p>
<figure><pre><code>| tree dict |
tree := (XMLHTMLParser parseURL: 'http://gatherer.wizards.com/Pages/Card/Details.aspx?multiverseid=389430').
container := tree xpath: '//div[@class=''row'']/div[@class=''label'']| //div[@class=''row'']/div[@class=''value'']'.
dict := ((container collect: [ :each | each contentString trimBoth  ])
	asOrderedCollection groupsOf: 2 atATimeCollect: [ :x :y | x -&gt; y]) asDictionary.
	
NeoJSONWriter toStringPretty:dict
&gt;&gt;&gt;	

'{
	&quot;Card Number:&quot; : &quot;59&quot;,
	&quot;Card Name:&quot; : &quot;Arcane Lighthouse&quot;,
	&quot;Artist:&quot; : &quot;Igor Kieryluk&quot;,
	&quot;Types:&quot; : &quot;Land&quot;,
	&quot;Card Text:&quot; : &quot;: Add  to your mana pool. , : Until end of turn, creatures your opponents control lose
	 hexproof and shroud and can''t have hexproof or shroud.&quot;,
	&quot;Expansion:&quot; : &quot;Commander 2014&quot;,
	&quot;Rarity:&quot; : &quot;Uncommon&quot;
}'</code></pre><figcaption></figcaption></figure>

<p>
Now we can apply the same technique to access all the cards and also different pages to extract all the card unique id and query the database. 
But this is left as an exercise.
</p>
<h3>Conclusion</h3>

<p>
We show you how we could access the page and navigate interactively through it using XPath and live programming feature of Pharo.
This chapter should show the great value to be able to tweak you live a document and navigate to find the information you really want.

</p>

</p>

  </section>

</article>

<footer>

<div class="footline">
    <div class="github-link">
      <a href="" target="blank"><i class="fa fa-code-fork"></i>Github</a>
    </div>
  </div>
</footer>

<script src="/booklet-Scraping/html/_support/html/js/clipboard.min.js"></script>

<link href="/booklet-Scraping/html/_support/html/css/featherlight.min.css" rel="stylesheet">
<script src="/booklet-Scraping/html/_support/html/js/featherlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script src="/booklet-Scraping/html/_support/html/js/flex.js"></script>
<!-- Prettify annotated paragraphs-->
    <script src="/booklet-Scraping/html_support/html/js/annotated-paragraphs.js"></script>

  </body>
</html>
