<!DOCTYPE html>
<html>
  <head>
    <title></title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="shortcut icon" href="images/favicon.png" type="image/x-icon" />
<link href="/booklet-Scraping/html/_support/html/css/font-awesome.min.css" rel="stylesheet">
<link href="/booklet-Scraping/html/_support/html/css/nucleus.css" rel="stylesheet">
<link href="/booklet-Scraping/html/_support/html/css/flex.css" rel="stylesheet">
<link rel="stylesheet" href="/booklet-Scraping/html/_support/html/highlightjs/styles/default.css">
<link rel="stylesheet" href="/booklet-Scraping/html/_support/html/css/highlight-commands.css">
<link rel="stylesheet" href="/booklet-Scraping/html/_support/html/css/bootstrap.min.css">
<script src="/booklet-Scraping/html/_support/html/js/jquery-2.x.min.js"></script>
<script src="/booklet-Scraping/html/_support/html/highlightjs/highlight.pack.js"></script>
<script src="/booklet-Scraping/html/_support/html/js/highlight-commands.js"></script>
<meta name="description" content="">
<meta name="author" content="StÃ©phane Ducasse and Peter Kenny">
  </head>
  <body>
    <header>
  <div class="logo">
    <a class="baselink" href="/booklet-Scraping/html"></a>
  </div>
  <div class="burger"><a href="javascript:void(0);" style="font-size:15px;">&#9776;</a></div>
  
</header>
<article>
  <aside>
    <ul class="menu">
   		<li data-nav-id="123" class="dd-item">
    		<a href="/booklet-Scraping/html">
		       <i class="fa fa-fw fa-home"></i>
	    	</a>
        </li>

		
		  <li class="dd-item  haschildren ">
			<div>
			  <a href="/booklet-Scraping/html/Chapters/XPath.html#little journey into xpath">
					Little Journey into XPath
			  </a>
			   <i class="fa fa-angle-right fa-lg category-icon"></i> 
			</div>
			  <ul class="dd-item">
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Scraping/html/Chapters/XPath.html#getting started">
							Getting started
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Scraping/html/Chapters/XPath.html#an example">
							An example
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Scraping/html/Chapters/XPath.html#creating a tree of objects">
							Creating a tree of objects
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Scraping/html/Chapters/XPath.html#nodes, node sets and atomic values">
							Nodes, node sets and atomic values
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Scraping/html/Chapters/XPath.html#basic tree relationships">
							Basic tree relationships
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Scraping/html/Chapters/XPath.html#a large example">
							A large example
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item  haschildren ">
					<div>
						<a href="/booklet-Scraping/html/Chapters/XPath.html#node selection">
							Node selection
						</a>
						<i class="fa fa-angle-right fa-lg category-icon"></i>
					</div>

					<ul class="dd-item">
							
						<li class="dd-item">
							<a href="/booklet-Scraping/html/Chapters/XPath.html#node tag name selection">Node tag name selection</a>
						</li>
							
						<li class="dd-item">
							<a href="/booklet-Scraping/html/Chapters/XPath.html#context and parent">Context and parent</a>
						</li>
							
						<li class="dd-item">
							<a href="/booklet-Scraping/html/Chapters/XPath.html#matching path-based child nodes">Matching path-based child nodes</a>
						</li>
							
						<li class="dd-item">
							<a href="/booklet-Scraping/html/Chapters/XPath.html#matching deep nodes">Matching deep nodes</a>
						</li>
							
						<li class="dd-item">
							<a href="/booklet-Scraping/html/Chapters/XPath.html#identifying attributes">Identifying attributes</a>
						</li>
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item  haschildren ">
					<div>
						<a href="/booklet-Scraping/html/Chapters/XPath.html#predicates">
							Predicates
						</a>
						<i class="fa fa-angle-right fa-lg category-icon"></i>
					</div>

					<ul class="dd-item">
							
						<li class="dd-item">
							<a href="/booklet-Scraping/html/Chapters/XPath.html#first element">First element</a>
						</li>
							
						<li class="dd-item">
							<a href="/booklet-Scraping/html/Chapters/XPath.html#other position functions">Other position functions</a>
						</li>
							
						<li class="dd-item">
							<a href="/booklet-Scraping/html/Chapters/XPath.html#selecting based on node value">Selecting based on node value</a>
						</li>
							
						<li class="dd-item">
							<a href="/booklet-Scraping/html/Chapters/XPath.html#selecting nodes based on attribute value">Selecting nodes based on attribute value</a>
						</li>
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Scraping/html/Chapters/XPath.html#selecting unknown nodes">
							Selecting Unknown Nodes
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Scraping/html/Chapters/XPath.html#handling multiple queries">
							Handling multiple queries
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item  haschildren ">
					<div>
						<a href="/booklet-Scraping/html/Chapters/XPath.html#xpath axes">
							XPath axes
						</a>
						<i class="fa fa-angle-right fa-lg category-icon"></i>
					</div>

					<ul class="dd-item">
							
						<li class="dd-item">
							<a href="/booklet-Scraping/html/Chapters/XPath.html#paths ">Paths </a>
						</li>
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Scraping/html/Chapters/XPath.html#conclusion">
							Conclusion
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
			  </ul>
		  
		  </li>
		
		  <li class="dd-item  haschildren ">
			<div>
			  <a href="/booklet-Scraping/html/Chapters/Scraping.html#scraping html">
					Scraping HTML
			  </a>
			   <i class="fa fa-angle-right fa-lg category-icon"></i> 
			</div>
			  <ul class="dd-item">
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Scraping/html/Chapters/Scraping.html#getting started">
							Getting started
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Scraping/html/Chapters/Scraping.html#define the problem">
							Define the Problem
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Scraping/html/Chapters/Scraping.html#first find the required data">
							First find the required data
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Scraping/html/Chapters/Scraping.html#going back to our problem">
							Going back to our problem
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Scraping/html/Chapters/Scraping.html#turning the pages">
							Turning the pages
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Scraping/html/Chapters/Scraping.html#conclusion ">
							Conclusion 
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
			  </ul>
		  
		  </li>
		
		  <li class="dd-item  haschildren ">
			<div>
			  <a href="/booklet-Scraping/html/Chapters/Scraping2.html#scraping magic ">
					Scraping Magic 
			  </a>
			   <i class="fa fa-angle-right fa-lg category-icon"></i> 
			</div>
			  <ul class="dd-item">
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Scraping/html/Chapters/Scraping2.html#getting a tree">
							Getting a tree
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item  haschildren ">
					<div>
						<a href="/booklet-Scraping/html/Chapters/Scraping2.html#first the card visual ">
							First the card visual 
						</a>
						<i class="fa fa-angle-right fa-lg category-icon"></i>
					</div>

					<ul class="dd-item">
							
						<li class="dd-item">
							<a href="/booklet-Scraping/html/Chapters/Scraping2.html#no so cool but working... ">No so cool but working... </a>
						</li>
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Scraping/html/Chapters/Scraping2.html#revisiting it">
							Revisiting it
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Scraping/html/Chapters/Scraping2.html#getting data">
							Getting data
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Scraping/html/Chapters/Scraping2.html#conclusion">
							Conclusion
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
			  </ul>
		  
		  </li>
		
    </ul>
  </aside>

  <section class="page">
    
	<h1>Scraping HTML with XPath</h1>
		
	<h2>Little Journey into XPath</h2>

<p>
XPath is the de factor standard language for navigating an XML document and selecting nodes from it. XPath expressions act as queries that identifies nodes. In this chapter we will go through the main concepts and show some of the ways we can access nodes in a xml document. All the expressions can be executed on the spot, so do not hesitate to experiment with them.
</p>
<h3>Getting started</h3>

<p>
You should load the XML parser and XPath library as follows:
</p><figure><pre><code>Gofer it
   smalltalkhubUser: 'PharoExtras' project: 'XMLParserHTML';
   configurationOf: 'XMLParserHTML';
   loadStable.</code></pre><figcaption></figcaption></figure>

<figure><pre><code>Gofer it
   smalltalkhubUser: 'PharoExtras' project: 'XPath';
   configurationOf: 'XPath';
   loadStable.</code></pre><figcaption></figcaption></figure>


<h3>An example</h3>

<p>
As an example we will take the possible representation of Magic cards, starting with the 
 Arcane Lighthouse that you can view at <a href="http://gatherer.wizards.com/Pages/Card/Details.aspx?multiverseid=389430">http://gatherer.wizards.com/Pages/Card/Details.aspx?multiverseid=389430</a>
and is shown in Figure <a href="#ligthouse"></a>. 
</p>
<p>
<a id="ligthouse"></a>
<figure>
	<img src="figures/lighthouse.png" width="100%" id="ligthouse" alt="http://gatherer.wizards.com/Pages/Card/Details.aspx?multiverseid=389430."/>
	<figcaption>http://gatherer.wizards.com/Pages/Card/Details.aspx?multiverseid=389430.</figcaption>
</figure>
</p>
<figure><pre><code>	&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

	&lt;cardset&gt;
	  &lt;card&gt;
	    &lt;cardname lang=&quot;en&quot;&gt;Arcane Lighthouse&lt;/cardname&gt;
	    &lt;types&gt;Land&lt;/types&gt;
	    &lt;year&gt;2014&lt;/year&gt;
		&lt;rarity&gt;Uncommon&lt;/rarity&gt;
		&lt;expansion&gt;Commander 2014&lt;/expansion&gt;
	    &lt;cardtext&gt;Tap: Add 1 uncolor to you mana pool. 
		1 uncolor + Tap: Until end of turn, creatures your opponents
		 control lose hexproof and shroud and can't have 
		 hexproof or shroud.&lt;/cardtext&gt;
	  &lt;/card&gt;
	&lt;/cardset&gt;</code></pre><figcaption></figcaption></figure>

<h3>Creating a tree of objects</h3>

<p>
In Pharo it is always powerful to get an object and interact with it. 
So let us do that now using the <code>XMLDOMParser</code> to convert our data in a tree of objects (as shown in Figure <a href="#inspectorx"></a>).
Note that the escaped the <code>'</code> with an extra quote as in <code>can''t</code>. 
</p>
<figure><pre><code>	| tree |
	tree := (XMLDOMParser on: 
	'&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

	&lt;cardset&gt;
	  &lt;card&gt;
	    &lt;cardname lang=&quot;en&quot;&gt;Arcane Lighthouse&lt;/cardname&gt;
	    &lt;types&gt;Land&lt;/types&gt;
	    &lt;year&gt;2014&lt;/year&gt;
	    &lt;rarity&gt;Uncommon&lt;/rarity&gt;
	    &lt;expansion&gt;Commander 2014&lt;/expansion&gt;
	    &lt;cardtext&gt;Tap: Add 1 uncolor to you mana pool. 
		1 uncolor + Tap: Until end of turn, creatures your opponents
		 control lose hexproof and shroud and can''t have 
		 hexproof or shroud.&lt;/cardtext&gt;
	  &lt;/card&gt;
	&lt;/cardset&gt;') parseDocument</code></pre><figcaption></figcaption></figure>


<p>
<a id="inspectorx"></a>
<figure>
	<img src="figures/xpath1.png" width="100%" id="inspectorx" alt="Grabbing and playing with a tree."/>
	<figcaption>Grabbing and playing with a tree.</figcaption>
</figure>
</p>
<h3>Nodes, node sets and atomic values</h3>
<p>
We will be working with three kinds of XPath constructs: nodes, node sets, and atomic values.
</p>
<p>
Node sets are sets (duplicate-free collections) of nodes. All node sets produced by XPath location path expressions are sorted in document order, the order in the document source that they appear in.
</p>
<p>
The following elements are nodes:
</p><figure><pre><code>&lt;cardset&gt; (root element node)

&lt;cardname lang=&quot;en&quot;&gt;Arcane Lighthouse&lt;/cardname&gt; (element node)

lang=&quot;en&quot; (attribute node)</code></pre><figcaption></figcaption></figure>

<p>
Atomic values are strings, numbers, and booleans. Here are some examples of atomic values:
</p>
<figure><pre><code>Arcane Lighthouse
 
&quot;en&quot;

2.5

-1

true

false</code></pre><figcaption></figcaption></figure>


<h3>Basic tree relationships</h3>

<p>
Since we are talking about trees, nodes can have multiple relationships with each other: parent, child and siblings. 
Let us set some simple vocabulary. 
</p>
<ul>
<li><strong>Parent.</strong> Each node can have at most one parent. The root node of the tree, usually a document, has no parent. In the Arcane Lighthouse example, the card element is the parent of the cardname, types, year, rarity, expansion and cardtext elements. In XPath, attribute and namespace nodes treat the element they belong to as their parent.</li>
</ul>

<ul>
<li><strong>Children.</strong> Document and element nodes may have zero, one or more children, which can be elements, text nodes, comments or processing instructions. The cardname, types, year, rarity, expansion and cardtext elements are all children of the card element. Confusingly, even though attribute and namespace nodes can have element parents in XPath, they aren't children of their parent elements.</li>
</ul>

<ul>
<li><strong>Siblings.</strong> Siblings are child nodes that have the same parent. The cardname, types, year, rarity, expansion and cardtext elements are all siblings. Attributes and and namespace nodes have no siblings.</li>
</ul>

<ul>
<li><strong>Ancestors.</strong> A node's parent, parent's parent, etc. Ancestors of the cardname element are the card element and the cardset nodes. </li>
</ul>

<ul>
<li><strong>Descendants</strong> A node's children, children's children, etc. Descendants of the cardset element are the card,cardname, types, year, rarity, expansion and cardtext elements.</li>
</ul>


<h3>A large example</h3>

<p>
Let us expand our example to have cover more cases.
</p>
<figure><pre><code>	
	| tree |
	tree := (XMLDOMParser on: 
	'&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

	&lt;cardset&gt;
	  &lt;card&gt;
	    &lt;cardname lang=&quot;en&quot;&gt;Arcane Lighthouse&lt;/cardname&gt;
	    &lt;types&gt;Land&lt;/types&gt;
	    &lt;year&gt;2014&lt;/year&gt;
	    &lt;rarity&gt;Uncommon&lt;/rarity&gt;
	    &lt;expansion&gt;Commander 2014&lt;/expansion&gt;
	    &lt;cardtext&gt;Tap: Add 1 uncolor to you mana pool. 
		1 uncolor + Tap: Until end of turn, creatures your opponents
		 control lose hexproof and shroud and can''t have 
		 hexproof or shroud.&lt;/cardtext&gt;
	  &lt;/card&gt;
	  &lt;card&gt;
	    &lt;cardname lang=&quot;en&quot;&gt;Desolate Lighthouse&lt;/cardname&gt;
	    &lt;types&gt;Land&lt;/types&gt;
	    &lt;year&gt;2013&lt;/year&gt;
	    &lt;rarity&gt;Rare&lt;/rarity&gt;
	    &lt;expansion&gt;Avacyn Restored&lt;/expansion&gt;
	    &lt;cardtext&gt;Tap: Add Colorless to your mana pool.
	1BlueRed, Tap: Draw a card, then discard a card.&lt;/cardtext&gt;
	  &lt;/card&gt;
	&lt;/cardset&gt;') parseDocument</code></pre><figcaption></figcaption></figure>

<p>
<a id="inspector2"></a>
<figure>
	<img src="figures/xpath2.png" width="100%" id="inspector2" alt="Select the raw tab and click on self in the inspector."/>
	<figcaption>Select the raw tab and click on self in the inspector.</figcaption>
</figure>
</p>
<p>
Select the raw tab and click on self in the inspector (as shown in Figure <a href="#inspector2"></a>). Now we are ready to learn XPath.
</p>
<h3>Node selection</h3>

<p>
The following table shows the XPath expressions. Often the current node is also named the context. 
</p>
<table style="border: solid thin"><tr><td><strong>Expression</strong></td>
<td><strong>Description</strong></td>
<td></td>
</tr>
<tr><td>nodename</td>
<td>Selects all child nodes with the name &quot;nodename&quot;</td>
<td></td>
</tr>
<tr><td>/</td>
<td>Selects the root node</td>
<td></td>
</tr>
<tr><td>//</td>
<td>Selects any node from the current node that match the context selection</td>
<td></td>
</tr>
<tr><td>.</td>
<td>Selects the context (current) node</td>
<td></td>
</tr>
<tr><td>..</td>
<td>Selects the parent of the context (current) node</td>
<td></td>
</tr>
<tr><td>@</td>
<td>Selects attributes of the context node</td>
<td></td>
</tr>
</table>


<p>
In the following we expect that the variable <code>tree</code> is bound the full document tree we previously created parsing the XML string.
Location path expressions return node sets, which are empty if no nodes match. Now let us play with the system to really see how it works.
</p>
<h4>Node tag name selection</h4>

<p>
There are several way to test and select nodes.
</p>
<table style="border: solid thin"><tr><td><strong>nodename</strong></td>
<td>Selects all child nodes with the name &quot;nodename&quot;</td>
<td></td>
</tr>
<tr><td>card</td>
<td>Selects all child nodes with the name &quot;card&quot;</td>
<td></td>
</tr>
<tr><td><strong>prefix:localName</strong></td>
<td>Selects all child nodes with the qualified name &quot;prefix:localName&quot;</td>
<td></td>
</tr>
<tr><td></td>
<td>or if at least one prefix/namespace URI pair was declared in the</td>
<td></td>
</tr>
<tr><td></td>
<td>XPathContext, the child nodes with the local name &quot;localName&quot;</td>
<td></td>
</tr>
<tr><td></td>
<td>and the namespace URI bound to &quot;prefix&quot;</td>
<td></td>
</tr>
</table>

<p>
In standard XPath, qualified name tests like prefix:localName select nodes with the same local name and the namespace URI of the prefix, which must be declared in the controlling XPath context prior to evaluation. The selected nodes from the document can have different prefixes (or none at all), because matching is based on local name and namespace URI.
</p>
<p>
To simplify things, the Pharo XPath library (unlike others) by default matches qualified name tests against the literal qualified names of nodes, ignoring namespace URIs completely, and does not require you to pre-declare namespace prefix/URI pairs in the XPathContext object before evaluation. Declaring at least one namespace prefix/URI pair will trigger standard behavior, where all prefixes used in qualified name tests must be pre-declared, and matching will be done based on local names and namespace URIs.
</p>
<h4>Context and parent</h4>

<table style="border: solid thin"><tr><td>.</td>
<td>Selects the current context node</td>
<td></td>
</tr>
<tr><td>..</td>
<td>Selects the parent of the current context node</td>
<td></td>
</tr>
</table>

<p>
The following expression shows that <code>.</code> (period) selects the context node, initially the node XPath evaluation begins in.
</p>
<figure><pre><code>(tree xpath: '.') first == tree
&gt;&gt;&gt; true</code></pre><figcaption></figcaption></figure>



<h4>Matching path-based child nodes</h4>

<p>
The operator <code>/</code> selects from the root node.
</p>
<table style="border: solid thin"><tr><td><strong>/</strong></td>
<td><strong>Selects from the root node</strong></td>
<td></td>
</tr>
<tr><td>/cardset</td>
<td>Selects the root element cardset</td>
<td></td>
</tr>
<tr><td>cardset/card</td>
<td>Selects all the card grandchildren from the cardset children of the context node</td>
<td></td>
</tr>
</table>

<p>
The following expression selects all the card nodes under cardset node.
</p>
<figure><pre><code>path := XPath for: '/cardset/card'.
path in: tree.</code></pre><figcaption></figcaption></figure>

<p>
<code>XPath</code> objects lazily compile their source to an executable form the first time they're evaluated, and the compiled form and its source are cached globally, so caching the <code>XPath</code> object itself in a variable is normally unecessary to avoid recompilation and is only slightly faster. The previous expression is equivalent to the following expression using the <code>xpath:</code> message.
</p>
<figure><pre><code>tree xpath: '/cardset/card'</code></pre><figcaption></figcaption></figure>



<h4>Matching deep nodes</h4>

<p>
The <code>//</code> operation selects all the nodes matching the selection.
</p>

<table style="border: solid thin"><tr><td><strong>//</strong></td>
<td>Selects from the context (current) node and all descendants</td>
<td></td>
</tr>
<tr><td>//year</td>
<td>Selects all year node children of the context node and of its descendants</td>
<td></td>
</tr>
<tr><td>cardset//year</td>
<td>Selects all year node children of the cardset context node children and their descendants</td>
<td></td>
</tr>
</table>

<p>
Let us try with another element such as the expansion of a card. 
</p><figure><pre><code>tree xpath: '//expansion'
&gt;&gt;&gt;
a XPathNodeSet(&lt;expansion&gt;Commander 2014&lt;/expansion&gt; &lt;expansion&gt;Avacyn Restored&lt;/expansion&gt;)</code></pre><figcaption></figcaption></figure>

<p>
The XPath library extends <code>XMLNode</code> classes with binary selectors to encode certain XPath expressions directly in Pharo. So the previous expression can be expressed as follows using the message <code>//</code>:
</p>
<figure><pre><code>tree // 'expansion'
&gt;&gt;&gt;
a XPathNodeSet(&lt;expansion&gt;Commander 2014&lt;/expansion&gt; &lt;expansion&gt;Avacyn Restored&lt;/expansion&gt;)</code></pre><figcaption></figcaption></figure>


<h4>Identifying attributes</h4>

<p>
<code>@</code> matches attributes. 
</p>
<table style="border: solid thin"><tr><td><strong>Expression</strong></td>
<td><strong>Description</strong></td>
<td></td>
</tr>
<tr><td>@</td>
<td>Selects attributes</td>
<td></td>
</tr>
<tr><td>//@lang</td>
<td>Selects all attributes that are named lang</td>
<td></td>
</tr>
</table>
<p>
 
</p>

<p>
The following expression returns all the attributes whose name is <code>lang</code>.
</p><figure><pre><code>(tree xpath: '//@lang') 
&gt;&gt;&gt;  a XPathNodeSet(lang=&quot;&quot;en&quot;&quot; lang=&quot;&quot;en&quot;&quot;)</code></pre><figcaption></figcaption></figure>



<h3>Predicates</h3>

<p>
Predicates are used to find a specific node or a node that contains a specific value. Predicates are always embedded in square brackets.
</p>
<p>
Let us study some examples:
</p>
<h4>First element</h4>

<p>
The following expression selects the first card child of the cardset element.
</p><figure><pre><code>tree xpath: '/cardset/card[1]'
&gt;&gt;&gt;
a XPathNodeSet(&lt;card&gt;
    &lt;cardname lang=&quot;&quot;en&quot;&quot;&gt;Arcane Lighthouse&lt;/cardname&gt;
    &lt;types&gt;Land&lt;/types&gt;
    &lt;year&gt;2014&lt;/year&gt;
    &lt;rarity&gt;Uncommon&lt;/rarity&gt;
    &lt;expansion&gt;Commander 2014&lt;/expansion&gt;
    &lt;cardtext&gt;Tap: Add 1 uncolor to you mana pool. 
	1 uncolor + Tap: Until end of turn, creatures your opponents
	 control lose hexproof and shroud and can't have 
	 hexproof or shroud.&lt;/cardtext&gt;
  &lt;/card&gt;)</code></pre><figcaption></figcaption></figure>

<p>
In the XPath Pharo implementation, the message <code>??</code> can be used for position or block predicates.
</p>
<p>
the previous expression is equivalent to the following one
</p>
<figure><pre><code>tree / 'cardset' / ('card' ?? 1) .</code></pre><figcaption></figcaption></figure>


<p>
Block or position predicates can be applied with <code>??</code> to axis node test arguments or to result node sets. 
</p>
<p>
The following expression returns the first element of each 'card' descendant:
</p>
<figure><pre><code>tree // 'card' / ('*' ?? 1)
&gt;&gt;&gt; &quot;a XPathNodeSet(&lt;cardname lang=&quot;&quot;en&quot;&quot;&gt;Arcane Lighthouse&lt;/cardname&gt; &lt;cardname lang=&quot;&quot;en&quot;&quot;&gt;Desolate Lighthouse&lt;/cardname&gt;)&quot;</code></pre><figcaption></figcaption></figure>

<h4>Other position functions</h4>

<p>
The following expression selects the last card node that is the child of the cardset node.
</p>
<figure><pre><code>tree xpath: '/cardset/card[last()]'.</code></pre><figcaption></figcaption></figure>

<p>
The following selects the second to last node. In our case since we only have two elements we get the first. 
</p>
<figure><pre><code>tree xpath: '/cardset/card[last()-1]'.
&gt;&gt;&gt;
a XPathNodeSet(&lt;card&gt;
	    &lt;cardname lang=&quot;&quot;en&quot;&quot;&gt;Arcane Lighthouse&lt;/cardname&gt;
	    &lt;types&gt;Land&lt;/types&gt;
	    &lt;year&gt;2014&lt;/year&gt;
	    &lt;rarity&gt;Uncommon&lt;/rarity&gt;
	    &lt;expansion&gt;Commander 2014&lt;/expansion&gt;
	    &lt;cardtext&gt;Tap: Add 1 uncolor to you mana pool. 
		1 uncolor + Tap: Until end of turn, creatures your opponents
		 control lose hexproof and shroud and can't have 
		 hexproof or shroud.&lt;/cardtext&gt;
	  &lt;/card&gt;)</code></pre><figcaption></figcaption></figure>

<p>
We can also use the position function and use it to identify nodes. The following selects the first two card nodes that are children of the cardset node. 
</p>
<figure><pre><code>(tree xpath: '/cardset/card[position()&lt;3]') size = 2
&gt;&gt;&gt; true</code></pre><figcaption></figcaption></figure>


<h4>Selecting based on node value</h4>

<p>
In addition we can select nodes based on a value of a node. The following query selects all the card nodes (of the cardset) that have a year greater than 2014.
</p>
<figure><pre><code>tree xpath: '/cardset/card[year&gt;2013]'.</code></pre><figcaption></figcaption></figure>

<p>
The following query selects all the cardname nodes of the card children of cardset that have a year greater than 2014.
</p>
<figure><pre><code>/cardset/card[year&gt;2013]/cardname
&gt;&gt;&gt; a XPathNodeSet(&lt;cardname lang=&quot;&quot;en&quot;&quot;&gt;Arcane Lighthouse&lt;/cardname&gt;)</code></pre><figcaption></figcaption></figure>

<h4>Selecting nodes based on attribute value</h4>

<p>
We can also select nodes based on the existence or value of an attribute.
The following expression returns the cardname that have the lang attribute and whose value is 'en'.
</p><figure><pre><code>tree xpath: '//cardname[@lang]
&gt;&gt;&gt; a XPathNodeSet(&lt;cardname lang=&quot;&quot;en&quot;&quot;&gt;Arcane Lighthouse&lt;/cardname&gt; &lt;cardname lang=&quot;&quot;en&quot;&quot;&gt;Desolate Lighthouse&lt;/cardname&gt;)
tree xpath: '//cardname[@lang='en']</code></pre><figcaption></figcaption></figure>

<p>
Note that we can simply get the card from the name using '..'.
</p>
<figure><pre><code>tree xpath: '//cardname[@lang='en']/..
&gt;&gt;&gt;</code></pre><figcaption></figcaption></figure>

<h3>Selecting Unknown Nodes</h3>

<p>
In addition we can use wildcard to select any node. 
</p>
<table style="border: solid thin"><tr><td><strong>Wildcard</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr><td>*</td>
<td>Matches any element node</td>
<td></td>
</tr>
<tr><td>@*</td>
<td>Matches any attribute node</td>
<td></td>
</tr>
<tr><td>node()</td>
<td>Matches any node of any kind</td>
<td></td>
</tr>
</table>

<p>
For example <code>//*</code> selects all elements in a document. 
</p>
<figure><pre><code>(tree xpath: '//*') size
&gt;&gt;&gt; 15</code></pre><figcaption></figcaption></figure>

<p>
While <code>//@*</code> selects all the attributes of any node. 
</p>
<figure><pre><code>tree xpath: '//@*'
&gt;&gt;&gt; a XPathNodeSet(lang=&quot;&quot;en&quot;&quot; lang=&quot;&quot;en&quot;&quot;)</code></pre><figcaption></figcaption></figure>

<p>
For example <code>//cardname[@*]</code> selects all cardname elements which have at least one attribute of any kind.
</p><figure><pre><code>tree xpath: '//cardname[@*]'
&gt;&gt;&gt; a XPathNodeSet(&lt;cardname lang=&quot;&quot;en&quot;&quot;&gt;Arcane Lighthouse&lt;/cardname&gt; &lt;cardname lang=&quot;&quot;en&quot;&quot;&gt;Desolate Lighthouse&lt;/cardname&gt;)</code></pre><figcaption></figcaption></figure>
<p>
The following expression selects all child nodes of cardset.
</p><figure><pre><code>tree xpath: '/cardset/*'.</code></pre><figcaption></figcaption></figure>

<p>
The following expression selects all the cardname of all the child nodes of cardset. 
</p><figure><pre><code>tree xpath: '/cardset/*/cardname'.</code></pre><figcaption></figcaption></figure>

<h3>Handling multiple queries</h3>

<p>
By using the <code>|</code> union operator in an XPath expression you can select several paths.
The following expression selects both the cardname and year of card nodes located anywhere in the document. 
</p>
<figure><pre><code>tree xpath: '//card/cardname | //card//year'
&gt;&gt;&gt; a XPathNodeSet(&lt;cardname lang=&quot;&quot;en&quot;&quot;&gt;Arcane Lighthouse&lt;/cardname&gt; &lt;year&gt;2014&lt;/year&gt; 
&lt;cardname lang=&quot;&quot;en&quot;&quot;&gt;Desolate Lighthouse&lt;/cardname&gt; &lt;year&gt;2013&lt;/year&gt;)&quot;</code></pre><figcaption></figcaption></figure>

<h3>XPath axes</h3>

<p>
XPath introduces another way to select nodes using <em>location step</em> following the syntax: <code>axisname::nodetest[predicate]</code>.
Such expressions can be used in the steps of location paths (see below). 
</p>
<p>
An axis defines a node-set relative to the context (current) node. Here is a table of the available axes. 
Except for the namespace axis, all of these have binary selector equivalents.
</p>
<table style="border: solid thin"><tr><td><strong>AxisName</strong></td>
<td><strong>Result</strong></td>
</tr>
<tr><td>ancestor</td>
<td>Selects all context (current) node ancestors</td>
</tr>
<tr><td>ancestor-or-self</td>
<td>... and the context node itself</td>
</tr>
<tr><td>attribute</td>
<td>Selects all context (current) node attributes</td>
</tr>
<tr><td>child</td>
<td>Selects all context (current) node children</td>
</tr>
<tr><td>descendant</td>
<td>Selects all context node descendants</td>
</tr>
<tr><td>descendant-or-self</td>
<td>... and the context node itself</td>
</tr>
<tr><td>following</td>
<td>Selects everything after the context node closing tag</td>
</tr>
<tr><td>following-sibling</td>
<td>Selects all siblings after the context node</td>
</tr>
<tr><td>namespace</td>
<td>Selects all context node namespace nodes</td>
</tr>
<tr><td>parent</td>
<td>Selects context node parent</td>
</tr>
<tr><td>preceding</td>
<td>Selects all nodes that appear before the context node</td>
</tr>
<tr><td></td>
<td>except ancestors, attribute nodes and namespace nodes</td>
</tr>
<tr><td>preceding-sibling</td>
<td>Selects all siblings before the context node</td>
</tr>
<tr><td>self</td>
<td>Selects the context node</td>
</tr>
</table>


<h4>Paths </h4>

<p>
A location path can be absolute or relative. An absolute location path starts with a slash ( / ) (/step/step/...) and a relative location path does not (step/step/...). In both cases the location path consists of one or more location steps, each separated by a slash.
</p>
<p>
Each step is evaluated against the nodes in the context node-set.
A location step, <code>axisname::nodetest[predicate]</code>,  consists of:
</p><ul>
<li>an axis (defines the tree-relationship between the selected nodes and the context node)</li>
<li>a node-test (identifies a node within an axis)</li>
<li>zero or more predicates (to further refine the selected node-set)</li>
</ul>

<p>
The following example access the year node of all the children of the cardset. 
</p><figure><pre><code>tree xpath: '/cardset/child::node()/year').
&gt;&gt;&gt;a XPathNodeSet(&lt;year&gt;2014&lt;/year&gt; &lt;year&gt;2013&lt;/year&gt;)</code></pre><figcaption></figcaption></figure>

<p>
The following expression gets the ancestor of the year node and selects the cardname.
</p><figure><pre><code>(tree xpath: '/cardset/card/year') first  xpath: 'ancestor::card/cardname'
&gt;&gt;&gt; &quot;a XPathNodeSet(&lt;cardname lang=&quot;&quot;en&quot;&quot;&gt;Arcane Lighthouse&lt;/cardname&gt;)&quot;</code></pre><figcaption></figcaption></figure>

<p>
The previous expression could be rewritten using a position predicate. Parentheses are needed so the predicate applies to the entire node set produced by the absolute location path, rather than just the last step, otherwise it would select the first year of each card, instead of the first year overall:
</p><figure><pre><code>(tree xpath: '(/cardset/card/year)[1]/ancestor::card/cardname'
&gt;&gt;&gt; &quot;a XPathNodeSet(&lt;cardname lang=&quot;&quot;en&quot;&quot;&gt;Arcane Lighthouse&lt;/cardname&gt;)&quot;</code></pre><figcaption></figcaption></figure>






<h3>Conclusion</h3>

<p>
XPath is a powerful language. The Pharo XPath library developed and maintained by Monty van OS and the Pharo Extras Team  implements the full standard 1.0. Coupled with the live programming capabilities of Pharo, it gives a really powerful way to explore structured XML data. 
</p>





  </section>

</article>

<footer>

<div class="footline">
    <div class="github-link">
      <a href="" target="blank"><i class="fa fa-code-fork"></i>Github</a>
    </div>
  </div>
</footer>

<script src="/booklet-Scraping/html/_support/html/js/clipboard.min.js"></script>

<link href="/booklet-Scraping/html/_support/html/css/featherlight.min.css" rel="stylesheet">
<script src="/booklet-Scraping/html/_support/html/js/featherlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script src="/booklet-Scraping/html/_support/html/js/flex.js"></script>
<!-- Prettify annotated paragraphs-->
    <script src="/booklet-Scraping/html_support/html/js/annotated-paragraphs.js"></script>

  </body>
</html>
