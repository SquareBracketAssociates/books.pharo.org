<!DOCTYPE html>
<html>
  <head>
    <title></title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="shortcut icon" href="images/favicon.png" type="image/x-icon" />
<link href="/booklet-Smacc/html/_support/html/css/font-awesome.min.css" rel="stylesheet">
<link href="/booklet-Smacc/html/_support/html/css/nucleus.css" rel="stylesheet">
<link href="/booklet-Smacc/html/_support/html/css/flex.css" rel="stylesheet">
<link rel="stylesheet" href="/booklet-Smacc/html/_support/html/highlightjs/styles/default.css">
<link rel="stylesheet" href="/booklet-Smacc/html/_support/html/css/highlight-commands.css">
<link rel="stylesheet" href="/booklet-Smacc/html/_support/html/css/bootstrap.min.css">
<script src="/booklet-Smacc/html/_support/html/js/jquery-2.x.min.js"></script>
<script src="/booklet-Smacc/html/_support/html/highlightjs/highlight.pack.js"></script>
<script src="/booklet-Smacc/html/_support/html/js/highlight-commands.js"></script>
<meta name="description" content="">
<meta name="author" content="John Brant, Jason Lecerf,  Thierry Goubier, StÃ©phane Ducasse, and Andrew Black">
  </head>
  <body>
    <header>
  <div class="logo">
    <a class="baselink" href="/booklet-Smacc/html"></a>
  </div>
  <div class="burger"><a href="javascript:void(0);" style="font-size:15px;">&#9776;</a></div>
  
</header>
<article>
  <aside>
    <ul class="menu">
   		<li data-nav-id="123" class="dd-item">
    		<a href="/booklet-Smacc/html">
		       <i class="fa fa-fw fa-home"></i>
	    	</a>
        </li>

		
		  <li class="dd-item  haschildren ">
			<div>
			  <a href="/booklet-Smacc/html/Chapters/Smacc/SmaccIntro.html#about this booklet">
					About this Booklet
			  </a>
			   <i class="fa fa-angle-right fa-lg category-icon"></i> 
			</div>
			  <ul class="dd-item">
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccIntro.html#contents">
							Contents
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccIntro.html#obtaining smacc">
							Obtaining SmaCC
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccIntro.html#basics">
							Basics
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
			  </ul>
		  
		  </li>
		
		  <li class="dd-item  haschildren ">
			<div>
			  <a href="/booklet-Smacc/html/Chapters/Smacc/SmaccTutorial.html#a first smacc tutorial">
					A First SmaCC Tutorial
			  </a>
			   <i class="fa fa-angle-right fa-lg category-icon"></i> 
			</div>
			  <ul class="dd-item">
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccTutorial.html#opening the tools">
							Opening the Tools
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item  haschildren ">
					<div>
						<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccTutorial.html#first, the scanner">
							First, the Scanner
						</a>
						<i class="fa fa-angle-right fa-lg category-icon"></i>
					</div>

					<ul class="dd-item">
							
						<li class="dd-item">
							<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccTutorial.html#ignoring whitespace">Ignoring Whitespace</a>
						</li>
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccTutorial.html#second, the calculator grammar">
							Second, the Calculator Grammar
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccTutorial.html#compile the scanner and the parser">
							Compile the Scanner and the Parser
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccTutorial.html#testing our parser">
							Testing our Parser
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccTutorial.html#defining actions">
							Defining Actions
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccTutorial.html#named expressions">
							Named Expressions
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccTutorial.html#extending the language">
							Extending the Language
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccTutorial.html#handling priority">
							Handling Priority
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccTutorial.html#handling priority with directives">
							Handling Priority with Directives
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
			  </ul>
		  
		  </li>
		
		  <li class="dd-item  haschildren ">
			<div>
			  <a href="/booklet-Smacc/html/Chapters/Smacc/SmaccScanner.html#smacc scanner">
					SmaCC Scanner
			  </a>
			   <i class="fa fa-angle-right fa-lg category-icon"></i> 
			</div>
			  <ul class="dd-item">
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccScanner.html#regular expression syntax">
							Regular Expression Syntax
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccScanner.html#overlapping tokens">
							Overlapping Tokens
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccScanner.html#token action methods">
							Token Action Methods
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccScanner.html#unreferenced tokens">
							Unreferenced Tokens
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccScanner.html#unicode characters">
							Unicode Characters
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
			  </ul>
		  
		  </li>
		
		  <li class="dd-item  haschildren ">
			<div>
			  <a href="/booklet-Smacc/html/Chapters/Smacc/SmaccParser.html#smacc parser">
					SmaCC Parser
			  </a>
			   <i class="fa fa-angle-right fa-lg category-icon"></i> 
			</div>
			  <ul class="dd-item">
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccParser.html#production rules">
							Production Rules
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccParser.html#named symbols">
							Named Symbols
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccParser.html#error recovery">
							Error Recovery
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccParser.html#shortcuts">
							Shortcuts
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
			  </ul>
		  
		  </li>
		
		  <li class="dd-item  haschildren ">
			<div>
			  <a href="/booklet-Smacc/html/Chapters/Smacc/SmaccDirectives.html#smacc directives">
					SmaCC Directives
			  </a>
			   <i class="fa fa-angle-right fa-lg category-icon"></i> 
			</div>
			  <ul class="dd-item">
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccDirectives.html#start symbols">
							Start Symbols
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccDirectives.html#id methods">
							Id Methods
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccDirectives.html#case insensitive scanning">
							Case Insensitive Scanning
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccDirectives.html#ast directives">
							AST Directives
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item  haschildren ">
					<div>
						<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccDirectives.html#dealing with ambiguous grammars">
							Dealing with Ambiguous Grammars
						</a>
						<i class="fa fa-angle-right fa-lg category-icon"></i>
					</div>

					<ul class="dd-item">
							
						<li class="dd-item">
							<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccDirectives.html#lr, lalr and ambiguous grammars">LR, LALR and Ambiguous Grammars</a>
						</li>
							
						<li class="dd-item">
							<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccDirectives.html#precedence rules">Precedence Rules</a>
						</li>
							
						<li class="dd-item">
							<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccDirectives.html#glr parsing">GLR Parsing</a>
						</li>
					
					</ul>						
				</li>
				
			  </ul>
		  
		  </li>
		
		  <li class="dd-item  haschildren ">
			<div>
			  <a href="/booklet-Smacc/html/Chapters/Smacc/SmaccAST.html#smacc abstract syntax trees">
					SmaCC Abstract Syntax Trees
			  </a>
			   <i class="fa fa-angle-right fa-lg category-icon"></i> 
			</div>
			  <ul class="dd-item">
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccAST.html#restarting">
							Restarting
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccAST.html#building nodes ">
							Building Nodes 
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccAST.html#variables and unnamed entities">
							Variables and Unnamed Entities
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccAST.html#unnamed symbols">
							Unnamed Symbols
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccAST.html#generating the ast">
							Generating the AST
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccAST.html#ast comparison">
							AST Comparison
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccAST.html#extending the visitor">
							Extending the Visitor
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
			  </ul>
		  
		  </li>
		
		  <li class="dd-item  haschildren ">
			<div>
			  <a href="/booklet-Smacc/html/Chapters/Smacc/SmaccAdvanced.html#advanced features of smacc">
					Advanced Features of SmaCC
			  </a>
			   <i class="fa fa-angle-right fa-lg category-icon"></i> 
			</div>
			  <ul class="dd-item">
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccAdvanced.html#multi-state scanners">
							Multi-state Scanners
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item  haschildren ">
					<div>
						<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccAdvanced.html#indentation-sensitive parsing">
							Indentation-Sensitive Parsing
						</a>
						<i class="fa fa-angle-right fa-lg category-icon"></i>
					</div>

					<ul class="dd-item">
							
						<li class="dd-item">
							<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccAdvanced.html#using token actions to customize the scanner">Using Token Actions to Customize the Scanner</a>
						</li>
							
						<li class="dd-item">
							<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccAdvanced.html#using newlines to separate statements">Using Newlines to Separate Statements</a>
						</li>
							
						<li class="dd-item">
							<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccAdvanced.html#augmenting the state of the scanner">Augmenting the State of the Scanner</a>
						</li>
							
						<li class="dd-item">
							<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccAdvanced.html#unnamed tokens">Unnamed Tokens</a>
						</li>
							
						<li class="dd-item">
							<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccAdvanced.html#closing blocks">Closing Blocks</a>
						</li>
							
						<li class="dd-item">
							<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccAdvanced.html#continuation lines">Continuation Lines</a>
						</li>
							
						<li class="dd-item">
							<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccAdvanced.html#ignoring blank lines">Ignoring Blank Lines</a>
						</li>
							
						<li class="dd-item">
							<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccAdvanced.html#the rest of the story">The Rest of the Story</a>
						</li>
					
					</ul>						
				</li>
				
			  </ul>
		  
		  </li>
		
		  <li class="dd-item  haschildren ">
			<div>
			  <a href="/booklet-Smacc/html/Chapters/Smacc/SmaccTransformations.html#smacc transformations">
					SmaCC Transformations
			  </a>
			   <i class="fa fa-angle-right fa-lg category-icon"></i> 
			</div>
			  <ul class="dd-item">
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccTransformations.html#defining transformations ">
							Defining Transformations 
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccTransformations.html#pattern matching expressions">
							Pattern matching Expressions
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccTransformations.html#example">
							Example
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccTransformations.html#parametrizing transformations">
							Parametrizing Transformations
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccTransformations.html#restrictions and limitations">
							Restrictions and Limitations
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
			  </ul>
		  
		  </li>
		
		  <li class="dd-item  haschildren ">
			<div>
			  <a href="/booklet-Smacc/html/Chapters/Smacc/SmaccIdioms.html#grammar idioms">
					Grammar Idioms
			  </a>
			   <i class="fa fa-angle-right fa-lg category-icon"></i> 
			</div>
			  <ul class="dd-item">
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccIdioms.html#managing lists">
							Managing Lists
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccIdioms.html#using shortcuts">
							Using Shortcuts
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccIdioms.html#expressing optional features">
							Expressing Optional Features
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
			  </ul>
		  
		  </li>
		
		  <li class="dd-item ">
			<div>
			  <a href="/booklet-Smacc/html/Chapters/Smacc/SmaccConclusion.html#conclusion">
					Conclusion
			  </a>
			  
			</div>
			  <ul class="dd-item">
				
			  </ul>
		  
		  </li>
		
		  <li class="dd-item  haschildren ">
			<div>
			  <a href="/booklet-Smacc/html/Chapters/Smacc/SmaccVocabulary.html#vocabulary">
					Vocabulary
			  </a>
			   <i class="fa fa-angle-right fa-lg category-icon"></i> 
			</div>
			  <ul class="dd-item">
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccVocabulary.html#reference example ">
							Reference Example 
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccVocabulary.html#metagrammar structure">
							Metagrammar structure
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item  haschildren ">
					<div>
						<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccVocabulary.html#elements ">
							Elements 
						</a>
						<i class="fa fa-angle-right fa-lg category-icon"></i>
					</div>

					<ul class="dd-item">
							
						<li class="dd-item">
							<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccVocabulary.html#production rule">Production rule</a>
						</li>
							
						<li class="dd-item">
							<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccVocabulary.html#tokens">Tokens</a>
						</li>
							
						<li class="dd-item">
							<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccVocabulary.html#keywords">Keywords</a>
						</li>
							
						<li class="dd-item">
							<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccVocabulary.html#non terminal">Non Terminal</a>
						</li>
							
						<li class="dd-item">
							<a href="/booklet-Smacc/html/Chapters/Smacc/SmaccVocabulary.html#variables">Variables</a>
						</li>
					
					</ul>						
				</li>
				
			  </ul>
		  
		  </li>
		
    </ul>
  </aside>

  <section class="page">
    
	<h1>Smacc: a Compiler-Compiler</h1>
		
	

<h2>About this Booklet</h2>

<p>
This booklet describes SmaCC, the Smalltalk Compiler-Compiler originally developed by John Brant. 
</p>
<h3>Contents</h3>
<p>
It contains:
</p><ul>
<li>A tutorial originally written by John Brant and Don Roberts (<a href="http://www.refactoryworkers.com/SmaCC.html">SmaCC</a>) and adapted to Pharo.</li>
<li>Syntax to declare Syntax trees.</li>
<li>Details about the directives.</li>
<li>Scanner and Parser details.</li>
<li>Support for transformations.</li>
<li>Idioms: Often we have recurring patterns and it is nice to document them.</li>
</ul>

<p>
SmaCC was ported to Pharo by Thierry Goubier, who actively maintains the SmaCC Pharo port.
SmaCC is used in production systems; for example, it supports the automatic conversion from Delphi to C#. 
</p>

<h3>Obtaining SmaCC</h3>
<p>
 
If you haven't already done so, you will need to load SmaCC.  Execute this code in a Pharo playground:
</p>
<figure><pre><code>Metacello new
	baseline: 'SmaCC';
	repository: 'github://SmaCCRefactoring/SmaCC';
	load</code></pre><figcaption></figcaption></figure>
<p>
 
 
Note that there is another version of SmaCC that John Brant ported later on to github (<a href="https://github.com/j-brant/SmaCC">https://github.com/j-brant/SmaCC</a>).
It is now also part of Moose <a href="http://moosetechnology.com">http://moosetechnology.com</a>.
The difference between them is that the Moose version uses different tools to load the parser and scanner. 
In the future, we hope that these versions will be unified.
</p>
<h3>Basics</h3>

<p>
The compilation process comprises of two phases: scanning (sometimes called lexing or lexical analysis) and parsing (which usually covers syntax analysis and semantic analysis).
Scanning converts an input stream of characters into a stream of <em>tokens</em>.
These tokens form the input to the parsing phase.
Parsing converts the stream of tokens into some object: exactly <em>what</em> object is determined by you, the user of SmaCC.

</p>
<h2>A First SmaCC Tutorial</h2>

<p>
This tutorial demonstrates the basic features of SmaCC, the Smalltalk Compiler Compiler. 
We will use SmaCC to create a simple calculator. 
This tutorial was originally developed by Don Roberts and John Brant, and later modified 
by T. Goubier, S. Ducasse, J. Lecerf and Andrew Black.
</p>

<h3>Opening the Tools</h3>
<p>
Once you have loaded the code of SmaCC, you should open the SmaCC Parser Generator tool (Figure <a href="#SmaCCGUI"></a>). 
In Pharo, you can do this using the <em>Tools</em> submenu of the <em>World</em> menu.
</p>
<p>
<a id="SmaCCGUI"></a>
<figure>
	<img src="Chapters/Smacc/figures/SmaCCGUI.png" width="80%" id="SmaCCGUI" alt="SmaCC GUI Tool: The place to define the scanner and parser."/>
	<figcaption>SmaCC GUI Tool: The place to define the scanner and parser.</figcaption>
</figure>
</p>
<p>
Our first calculator is going to be relatively simple. It is going to take two numbers and add them together. 
To use the SmaCC tool:
</p><ul>
<li>Edit the definition in the pane below the buttons.</li>
<li>Once you are done:<ul>
<li>Accept (with the context menu) or Save (the button)</li>
<li>Name your parser (and scanner) by typing a name (for example, CalculatorParser) in the text field at the left of the Parser label, followed by return.</li>
</ul>
</li>
<li>press either Compiler LR(1) or Compiled LALR(1) buttons to compile the parser.</li>
</ul>

<p>
You are now ready to edit your first scanner and parser. Note that you edit everything in one file (using the SmaCC tool).
Once compiled, the tools will generate two classes and fill them with sufficient information to create the scanner and parser, as shown as Figure <a href="#SmaCCTutorial"></a>.
</p>

<h3>First, the Scanner</h3>
<p>
To start things off, we have to tell the scanner how to recognize a number. A number starts with one or more digits, possibly followed by a decimal point with zero or more digits after it. The scanner definition for this token (called a token specification) is:
</p>
<figure><pre><code>&lt;number&gt;        :       [0-9]+ (\. [0-9]*) ? ;</code></pre><figcaption></figcaption></figure>

<p>
Let's go over each part:
</p>
<dl><dt><code>&lt;number&gt;</code></dt>
<dd>Names the token identified by the token specification. The name inside the &lt;&gt; must be a legal Pharo variable name.</dd>
<dt><code>:</code></dt>
<dd>Separates the name of the token from the token's definition.</dd>
<dt><code>[0-9]</code></dt>
<dd>Matches any single character in the range <code>'0'</code> to <code>'9'</code> (a digit). We could also use <code>\d</code> or <code>&lt;isDigit&gt;</code> as these also match digits.</dd>
<dt><code>+</code></dt>
<dd>Matches the previous expression one or more times. In this case, we are matching one or more digits.</dd>
<dt><code>( ... )</code></dt>
<dd>Groups subexpressions. In this case we are grouping the decimal point and the numbers following the decimal point.</dd>
<dt><code>\.</code></dt>
<dd>Matches the '.' character (<code>.</code> has a special meaning in regular expressions; <code>\</code> quotes it).</dd>
<dt><code>*</code></dt>
<dd>Matches the previous expression zero or more times.</dd>
<dt><code>?</code></dt>
<dd>Matches the previous expression zero or one time (i.e., it is optional).</dd>
<dt><code>;</code></dt>
<dd>Terminates a token specification.</dd>
</dl>


<h4>Ignoring Whitespace</h4>
<p>
We don't want to have to worry about whitespace in our language, so we need to define what whitespace is, and tell SmaCC to ignore it. To do this, enter the following token specification on the next line:
</p>
<figure><pre><code>&lt;whitespace&gt;    :       \s+;</code></pre><figcaption></figcaption></figure>

<p>
<code>\s</code> matches any whitespace character (space, tab, linefeed, etc.). So how do we tell the scanner to ignore it? If you look in the <code>SmaCCScanner</code> class (the superclass of all the scanners created by SmaCC), you will find a method named <code>whitespace</code>. If a scanner understands a method that has the same name as a token name, that method will be executed whenever the scanner matches that kind of token. As you can see, the <code>SmaCCScanner&gt;&gt;whitespace</code> method eats whitespace. 
</p>
<figure><pre><code>SmaCCScanner &gt;&gt; whitespace
	&quot;By default, eat the whitespace&quot;

	self resetScanner.
	^ self scanForToken</code></pre><figcaption></figcaption></figure>

<p>
<code>SmaCCScanner</code> also defines a <code>comment</code> method. That method both ignores the comment token (does not create a token for the parser) and stores the interval in the source where the comment occurred in the <code>comments</code> instance variable.
</p>
<figure><pre><code>SmaCCScanner &gt;&gt; comment
	comments add: (Array with: start + 1 with: matchEnd).
	^ self whitespace</code></pre><figcaption></figcaption></figure>

<p>
The only other token that will appear in our system is the <code>+</code> token for addition. However, since this token is a constant, there is no need to define it as a token in the scanner.  Instead, we will enter it directly (as a quoted string) in the grammar rules
that define the parser.
</p>
<h3>Second, the Calculator Grammar</h3>
<p>
Speaking of the grammar, let's go ahead and define it. Enter the following specification below your two previous rules in the editor pane, as shown in Figure <a href="#SmaCCTutorial"></a>.
</p>
<figure><pre><code>Expression 
	: Expression &quot;+&quot; Number
	| Number
	;
Number 
	: &lt;number&gt;
	;</code></pre><figcaption></figcaption></figure>

<p>
This basically says that an expression is either a number, or an expression added to a number. You should now have something that looks like Figure <a href="#SmaCCTutorial"></a>.
</p>
<p>
<a id="SmaCCTutorial"></a>
<figure>
	<img src="Chapters/Smacc/figures/SmaCCTutorial.png" width="80%" id="SmaCCTutorial" alt="First grammar: the Scanner part followed by the Parser part."/>
	<figcaption>First grammar: the Scanner part followed by the Parser part.</figcaption>
</figure>
</p>
<h3>Compile the Scanner and the Parser</h3>
<p>
We are almost ready to compile a parser now, but first we need to specify the names of the scanner and parser classes that SmaCC will create. These names are entered using the <code>...</code> buttons for scanner class and parser class. Enter <code>CalculatorScanner</code> and <code>CalculatorParser</code> respectively. Once the class names are entered, press Compile LR(1) or Compile LALR(1). This will create new Pharo classes for the <code>CalculatorScanner</code> and <code>CalculatorParser</code>, and compile several methods in those classes. All the methods that SmaCC compiles will go into a &quot;generated&quot; method protocol. You should not change those methods or add new methods to the &quot;generated&quot; method protocols, because these methods are replaced or deleted each time you compile.
</p>
<p>
Whenever SmaCC creates new classes, they are placed in the package (or package tag) named in the Package entry box. You may wish to select a different package by selecting it in the drop down menu or writing its name.
</p>
<h3>Testing our Parser</h3>

<p>
Now we are ready to test our parser. Go to the &quot;test&quot; pane, enter <code>3 + 4</code>, and press &quot;Parse&quot;; you will see that the parser correctly parses it. If you press &quot;Parse and inspect&quot; you will see an inspector on an OrderedCollection that contains the parsed tokens, as shown in Figure <a href="#3plus4Explorer"></a>. This is because we haven't specified what the parser is supposed to do when it parses.
</p>
<p>
You can also enter incorrect items as test input. For example, try to parse <code>3 + + 4</code> or <code>3 + a</code>. An error message should appear in the text.
</p>
<p>
<a id="3plus4Explorer"></a>
<figure>
	<img src="Chapters/Smacc/figures/3plus4Explorer.png" width="40%" id="3plus4Explorer" alt="Inspector on 3 + 4"/>
	<figcaption>Inspector on 3 + 4</figcaption>
</figure>
</p>

<p>
If you are interested in the generated parser, you may wish to look at the output from compiling the parser in the Symbols or Item Sets tab. 
</p>
<ul>
<li>The Symbols tab lists all of the terminal and non-terminal symbols that were used in the parser. The number besides each is the internal id used by the parser.</li>
<li>The Item Sets tab lists the LR item sets that were used in the parser. These are printed in a format that is similar to the format used by many text books.</li>
<li>The Messages tab is used to display any warnings generated while the parser was compiled. The most common warning is for ambiguous actions.</li>
</ul>

<h3>Defining Actions</h3>
<p>
Now we need to define the actions that need to happen when we parse our expressions. Currently, our parser is just validating that the expression is a bunch of numbers added together. Generally, you want to create some structure that represents what you've parsed (e.g., a parse tree). However, in this case, we are not concerned about the structure, but we are concerned about the result: the <em>value</em> of the expression. For our example, we can calculate the value by modifying the grammar to be:
</p>
<figure><pre><code>Expression 
	: Expression &quot;+&quot; Number {'1' + '3'}
	| Number {'1'}
	;
Number 
	: &lt;number&gt; {'1' value asNumber}
	;</code></pre><figcaption></figcaption></figure>

<p>
The text between the braces is Pharo code that is evaluated when the grammar rule is applied. Strings that contain a number are replaced with the corresponding expression in the production. For example, in the first rule for Expression, the <code>'1'</code> will be replaced by the object that matches Expression, and the <code>'3'</code> will be replaced by the object that matches <code>Number</code>. 
The second item in the rule is the <code>&quot;+&quot;</code> token. Since we already know what it is, there is no need to refer to it by number.
</p>
<p>
Compile the new parser. Now, when you do a 'Parse and inspect' from the test pane containing <code>3 + 4</code>, you should see the result: 7.
</p>
<h3>Named Expressions</h3>
<p>
One problem with the quoted numbers in the previous example is that if you change a rule, you may also need to change the code for that rule. For example, if you inserted a new token at the beginning of the rule for Expression, then you would also need to increment all of the numeric references in the Pharo code. 
</p>
<p>
We can avoid this problem by using named expressions. After each part of a rule, we can specify its name. Names are enclosed in single quotes, and must be legal Pharo variable names. Doing this for our grammar we get:
</p>
<figure><pre><code>Expression 
	: Expression 'expression' &quot;+&quot; Number 'number' {expression + number}
	| Number 'number' {number}
	;
Number 
	: &lt;number&gt; 'numberToken' {numberToken value asNumber}
	;</code></pre><figcaption></figcaption></figure>

<p>
This will result in the same language being parsed as in the previous example, with the same actions. Using named expressions makes it much easier to maintain your parsers. 
</p>
<h3>Extending the Language</h3>

<p>
Let's extend our language to add subtraction. Here is the new grammar:
</p>
<figure><pre><code>Expression 
	: Expression 'expression' &quot;+&quot; Number 'number' {expression + number}
	| Expression 'expression' &quot;-&quot; Number 'number' {expression - number}
	| Number 'number' {number}
	;
Number 
	: &lt;number&gt; 'numberToken' {numberToken value asNumber}
	;</code></pre><figcaption></figcaption></figure>

<p>
After you've compiled this, <code>'3 + 4 - 2'</code> should return <code>'5'</code>. Next, let's add multiplication and division:
</p>
<figure><pre><code>Expression 
	: Expression 'expression' &quot;+&quot; Number 'number' {expression + number}
	| Expression 'expression' &quot;-&quot; Number 'number' {expression - number}
	| Expression 'expression' &quot;*&quot; Number 'number' {expression * number}
	| Expression 'expression' &quot;/&quot; Number 'number' {expression / number}
	| Number 'number' {number}
	;
Number 
	: &lt;number&gt; 'numberToken' {numberToken value asNumber}
	;</code></pre><figcaption></figcaption></figure>


<h3>Handling Priority</h3>

<p>
Here we run into a problem. 
If you evaluate <code>'2 + 3 * 4'</code> you end up with 20. 
The problem is that in standard arithmetic, multiplication has a higher precedence than addition. 
Our grammar evaluates strictly left-to-right. 
The standard solution for this problem is to define additional non-terminals to force the sequence of evaluation. 
Using that solution, our grammar would look like this.
</p>
<figure><pre><code>Expression  
	: Term 'term' {term}
	| Expression 'expression' &quot;+&quot; Term 'term' {expression + term}
	| Expression 'expression' &quot;-&quot; Term 'term' {expression - term}
	;
Term 
	: Number 'number' {number}
	| Term 'term' &quot;*&quot; Number 'number' {term * number}
	| Term 'term' &quot;/&quot; Number 'number' {term / number}
	;
Number 
	: &lt;number&gt; 'numberToken' {numberToken value asNumber}
	;</code></pre><figcaption></figcaption></figure>

<p>
If you compile this grammar, you will see that <code>'2 + 3 * 4'</code> evaluates to <code>'14'</code>, as you would expect. 
</p>
<h3>Handling Priority with Directives</h3>

<p>
As you can imagine, defining additional non-terminals gets pretty complicated as the number of levels of precedence increases. 
We can use ambiguous grammars and precedence rules to simplify this situation. 
Here is the same grammar using precedence to enforce our desired evaluation order:
</p>
<figure><pre><code>%left &quot;+&quot; &quot;-&quot;;
%left &quot;*&quot; &quot;/&quot;;

Expression 
	: Expression 'exp1' &quot;+&quot; Expression 'exp2' {exp1 + exp2}
	| Expression 'exp1' &quot;-&quot; Expression 'exp2' {exp1 - exp2}
	| Expression 'exp1' &quot;*&quot; Expression 'exp2' {exp1 * exp2}
	| Expression 'exp1' &quot;/&quot; Expression 'exp2' {exp1 / exp2}
	| Number 'number' {number}
	;
Number 
	: &lt;number&gt; 'numberToken' {numberToken value asNumber}
	;</code></pre><figcaption></figcaption></figure>

<p>
Notice that we changed the grammar so that there are Expressions on both sides of the operator. 
This makes the grammar ambiguous: an expression like <code>'2 + 3 * 4'</code> can be parsed in two ways.  
This ambiguity is resolved using SmaCC's precedence rules.
</p>
<p>
The two lines that we added to the top of the grammar mean that <code>+</code> and <code>-</code> are evaluated left-to-right and have the same precedence. 
Likewise, the second line means that <code>*</code> and <code>/</code> are evaluated left-to-right and have equal precedence.
Because the rule for <code>+</code> and <code>-</code> comes first, <code>+</code> and <code>-</code> have lower precedence than <code>*</code> and <code>/</code>.
Grammars using precedence rules are usually much more intuitive, especially in cases with many precedence levels.
Just as an example, let's add exponentiation and parentheses. 
Here is our final grammar:
</p>
<figure><pre><code>&lt;number&gt; : [0-9]+ (\. [0-9]*) ? ;
&lt;whitespace&gt; : \s+;
%left &quot;+&quot; &quot;-&quot;;
%left &quot;*&quot; &quot;/&quot;;
%right &quot;^&quot;;

Expression 
	: Expression 'exp1' &quot;+&quot; Expression 'exp2' {exp1 + exp2}
	| Expression 'exp1' &quot;-&quot; Expression 'exp2' {exp1 - exp2}
	| Expression 'exp1' &quot;*&quot; Expression 'exp2' {exp1 * exp2}
	| Expression 'exp1' &quot;/&quot; Expression 'exp2' {exp1 / exp2}
	| Expression 'exp1' &quot;^&quot; Expression 'exp2' {exp1 raisedTo: exp2}
	| &quot;(&quot; Expression 'expression' &quot;)&quot; {expression}
	| Number 'number' {number}
	;
Number 
	: &lt;number&gt; 'numberToken' {numberToken value asNumber}
	;</code></pre><figcaption></figcaption></figure>

<p>
Once you have compiled the grammar, you will be able to evaluate <code>3 + 4 * 5 ^ 2 ^ 2</code> to get 2503.
Since the exponent operator <code>^</code> is defined to be right associative, this expression is evaluated as <code>3 + (4 * (5 ^ (2 ^ 2)))</code>.
We can also evaluate expressions with parentheses.
For example, evaluating <code>(3 + 4) * (5 - 2) ^ 3</code> results in 189.
</p>
<p>
The sections that follow provide more information on  SmaCC's scanner and parser, and on the directives that control SmaCC.
</p>
<p>
Subsequent sections explain how SmaCC can automatically produce an AST for you and how to use the Rewrite Engine.

</p>
<h2>SmaCC Scanner</h2>

<p>
Scanning takes an input stream of characters and converts that into a stream of tokens.
The tokens are then passed on to the parsing phase.
</p>
<p>
The scanner is specified by a collection of token specifications.
Each token is specified by:
</p>
<figure><pre><code>TokenName    :    RegularExpression ;</code></pre><figcaption></figcaption></figure>

<p>
TokenName is a valid  variable name surrounded by <code>&lt;&gt;</code>.
For example, <code>&lt;token&gt;</code> is a valid <code>TokenName</code>, but <code>&lt;token name&gt;</code> is not, as <code>token name</code> is not a valid variable name. 
The <code>RegularExpression</code> is a regular expression that matches a token. 
It should match one or more characters in the input stream. 
The colon character, <code>:</code>, is used to separate the TokenName and the <code>RegularExpression</code>, and the semicolon character, <code>;</code>, is used to terminate the token specification.
</p>

<h3>Regular Expression Syntax</h3>

<p>
While the rules are specified as regular expressions, there are many different syntaxes for regular expressions. 
SmaCC uses a relatively simple syntax, which is specified below. 
If you wish to have a richer syntax, you can modify the scanner's parser: <code>SmaCCDefinitionScanner</code> and <code>SmaCCDefinitionParser</code>. 
These classes were created using SmaCC and can be studied.
</p>

<dl><dt>\character</dt>
<dd>Matches a special character. The character immediately following the backslash is matched exactly, unless it is a letter. Backslash-letter combinations have other meanings and are specified below.</dd>
<dt>\cLetter</dt>
<dd>Matches a control character. Control characters are the first 26 characters (e.g., \cA equals <code>Character value: 0</code>). The letter that follows the <code>\c</code> must be an uppercase letter.</dd>
<dt>\d</dt>
<dd>Matches a digit, 0-9.</dd>
<dt>\D</dt>
<dd>Matches anything that is not a digit.</dd>
<dt>\f</dt>
<dd>Matches a form-feed character, <code>Character value: 12</code>.</dd>
<dt>\n</dt>
<dd>Matches a newline character, <code>Character value: 10</code>.</dd>
<dt>\r</dt>
<dd>Matches a carriage return character, <code>Character value: 13</code>.</dd>
<dt>\s</dt>
<dd>Matches any whitespace character, [ \f\n\r\t\v].</dd>
<dt>\S</dt>
<dd>Matches any non-whitespace character.</dd>
<dt>\t</dt>
<dd>Matches a tab, <code>Character value: 9</code>.</dd>
<dt>\v</dt>
<dd>Matches a vertical tab, <code>Character value: 11</code>.</dd>
<dt>\w</dt>
<dd>Matches any letter, number or underscore, <code>[A-Za-z0-9_]</code>.</dd>
<dt>\W</dt>
<dd>Matches anything that is not a letter, number or underscore.</dd>
<dt>\xHexNumber</dt>
<dd>Matches a character specified by the hex number following the <code>\x</code>. The hex number must be at least one character long and no more than four characters for Unicode characters and two characters for non-Unicode characters. For example, <code>\x20</code> matches the space character <code>(Character value: 16r20)</code>, and <code>\x1FFF</code> matches <code>Character value: 16r1FFF</code>.</dd>
<dt>&lt;token&gt;</dt>
<dd>Copies the definition of &lt;token&gt; into the current regular expression. For 	example, if we have <code>&lt;hexdigit&gt; : \d | [A-F] ;</code>, we can use <code>&lt;hexdigit&gt;</code> in a later rule: <code>&lt;hexnumber&gt; : &lt;hexdigit&gt; + ;</code>.  Note that you must define a token <em>before</em> you use it in another rule.</dd>
<dt>&lt;isMethod&gt;</dt>
<dd>Copies the characters where <code>Character&gt;&gt;isMethod</code> returns true into the current regular expression. For example, instead of using <code>\d</code>, we could use <code>&lt;isDigit&gt;</code> since <code>Character&gt;&gt;isDigit</code> returns true for digits.</dd>
<dt>[characters]</dt>
<dd>Matches one of the characters inside the [ ]. This is a shortcut for the <code>|</code> operator. In addition to single characters, you can also specify character ranges with the <code>-</code> character. For example, <code>[a-z]</code> matches any lower case letter.</dd>
<dt>[^characters]</dt>
<dd>Matches any character not listed in the characters block. <code>[^a]</code> matches anything except for <code>a</code>.</dd>
<dt># comment</dt>
<dd>Creates a comment that is ignored by SmaCC. Everything from the # to the end of the line is ignored.</dd>
<dt>exp1 | exp2</dt>
<dd>Matches either exp1 or exp2.</dd>
<dt>exp1 exp2</dt>
<dd>Matches exp1 followed by exp2. <code>\d \d</code> matches two digits.</dd>
<dt>exp*</dt>
<dd>Matches exp zero or more times. <code>0*</code> matches <code>''</code> and <code>000</code>.</dd>
<dt>exp?</dt>
<dd>Matches exp zero or one time. <code>0?</code> matches only <code>''</code> or <code>0</code>.</dd>
<dt>exp+</dt>
<dd>Matches exp one or more times. <code>0+</code> matches <code>0</code> and <code>000</code>, but not <code>''</code>.</dd>
<dt>exp{min,max}</dt>
<dd>Matches exp at least min times but no more than max times. <code>0{1,2}</code> matches only <code>0</code> or <code>00</code>. It does not match <code>''</code> or <code>000</code>.</dd>
<dt>(exp)</dt>
<dd>Groups exp for precedence. For example, <code>(a b)*</code> matches <code>ababab</code>. 	Without the parentheses, <code>a b *</code> would match <code>abbbb</code> but not <code>ababab</code>.</dd>
</dl>

<p>
Since there are multiple ways to combine expressions, we need precedence rules for their combination.
The or operator, <code>|</code>, has the lowest precedence and the <code>*</code>, <code>?</code>, <code>+</code>, and <code>{,}</code> operators have the highest precedence.
For example, <code>a | b c *</code> matches <code>a</code> or <code>bcccc</code>, but not <code>accc</code> or <code>bcbcbc</code>.
If you wish to match <code>a</code> or <code>b</code> followed by any number of c's, you need to use <code>(a | b) c *</code>.
</p>
<p>
Whitespace is ignored in SmaCC regular expressions everywhere <em>except</em> within square brackets.
This means that you can add spaces between terms to make your REs more readable.
However, inside square brackets, spaces are significant, so don't add spaces there unless you mean to include space (or, with <code>^</code>, to <em>exclude</em> space) from the set of allowable characters.
</p>

<h3>Overlapping Tokens</h3>

<p>
SmaCC can handle overlapping tokens without any problems.
For example, the following is a legal SmaCC scanner definition:
</p>
<figure><pre><code>&lt;variable&gt;	: [a-zA-Z] \w* ;
&lt;any_character&gt;	: . ;</code></pre><figcaption></figcaption></figure>

<p>
This definition will match a variable or a single character. 
A variable can also be a single character <code>[a-zA-Z]</code>, so the two tokens overlap. 
SmaCC handles overlapping tokens by preferring the longest matching token. 
If multiple token definitions match sequences of the same maximum length, first token specified by the grammar is chosen. 
For example, an <code>a</code> could be a <code>&lt;variable&gt;</code> or an <code>&lt;any_character&gt;</code> token, but since <code>&lt;variable&gt;</code> is specified first, SmaCC will prefer it.
SmaCC associate automatically a numerical id with each token name; overlapping tokens are implemented as a list of ids, and the preferred id is the first one.
</p>
<p>
If you want the parser to attempt to parse will all the possible kinds of token, override the method <code>SmaCCParser&gt;&gt;tryAllTokens</code> in your parser to answer <code>true</code> instead of <code>false</code>.
The effect of <code>#tryAllTokens</code> depends on the type of parser generated.
If GLR, then the parser will fork on all the ids of the token.
If non GLR (that is LR(1) or LALR(1)), the parser will try the other ids of the token if the first one triggers an error.
</p>

<h3>Token Action Methods</h3>
<a id="TokenActionMethods"></a>
<p>
A <em>Token Action Method</em> is a hand-written method in your scanner whose name is the same as the name of a token, (for example, the method <code>whitespace</code>).
For this reason, token action methods are sometimes also called &quot;matching methods&quot;.
</p>
<p>
A token action method will be executed whenever a token with the corresponding name is recognized.
We have already seen that the <code>SmaCCScanner</code> superclass has default implementations of methods <code>whitespace</code> and <code>comment</code>.
These methods are executed whenever the tokens <code>&lt;whitespace&gt;</code> and <code>&lt;comment&gt;</code> are scanned.
They ignore those tokens and record the comments ranges in the source text (which are made available inside SmaCC generated ASTs, see chapter <a href="#AST"></a>).
If you want to store comments, then you should study the approach used to record comments in <code>SmaCCScanner</code> and <code>SmaCCParser</code> and eventually modify the <code>SmaCCScanner&gt;&gt;comment</code> method.
</p>
<p>
When implementing a Token Action Method, you can find the characters that comprise the token in the <code>outputStream</code>, an instance variable inherited from <code>SmaCCScanner</code>.
Your method <em>must</em> answer a <code>SmaCCToken</code>.
Here are two examples.
</p>
<figure><pre><code>whitespace
	&quot;By default, eat the whitespace&quot;

	self resetScanner.
	^ self scanForToken</code></pre><figcaption></figcaption></figure>

<p>
This is the default action when spaces are scanned: the scanner is reset, and then used to scan for the token <em>following</em> the spaces.
This following token is returned; as a consequence, the spaces are ignored.
</p>
<figure><pre><code>leftBrace
	braceDepth := braceDepth + 1.
	^ self createTokenFor: '{'</code></pre><figcaption></figcaption></figure>

<p>
This is the token action from a scanner that needs to keep track of the number of <code>&lt;leftBrace&gt;</code> tokens.
After incrementing a counter, it returns the same token that would have been created if the there had been no token action.
</p>
<p>
Token Action Methods can also be used to handle overlapping token classes. For example, in the C grammar, a type definition is lexically identical to an identifier.
The only way that they can be disambiguated is by looking up the name in the symbol table.
In our example C scanner, we have an IDENTIFIER method that is used to determine whether the token is really an IDENTIFIER or whether it is a TYPE_NAME:
</p>
<figure><pre><code>IDENTIFIER
	| name |
	name := outputStream contents.
	matchActions := (typeNames includes: name)
		ifTrue: [ Array with: self TypeNameId ]
		ifFalse: [ Array with: self IDENTIFIERId ].
	outputStream reset.
	^ SmaCCToken value: name start: start ids: matchActions</code></pre><figcaption></figcaption></figure>

<p>
In this example, <code>#TypeNameId</code> and <code>#IDENTIFIERId</code> are methods generated by SmaCC with the <code>%id</code> directive (see subsection).
</p>
<h3>Unreferenced Tokens</h3>

<p>
If a token is not referenced from a grammar specification, it will not be included in the generated scanner, unless the token's name is also a name of a method (see previous section).
This, coupled with the ability to do substitutions, allows you to have the equivalent of macros within your scanner specification.
However, be aware that if you are simply trying to generate a scanner, you will have to make sure that you create a dummy parser specification that references all of the tokens that you want in the final scanner.
</p>

<h3>Unicode Characters</h3>

<p>
SmaCC compiles the scanner into a bunch of conditional tests on characters.
Normally, it assumes that characters have values between 0 and 255, and it can make some optimizations based on this fact.
With the directive <code>%unicode</code> in the input, SmaCC will assume that characters have values between 0 and 65535. 
Unicode characters outside that range are not presently handled, and SmaCC is significantly slower with this option activated.
</p>

<h2>SmaCC Parser</h2>

<p>
Parsing converts the stream of tokens provided by the scanner into some object.
By default, this object will be a parse tree, but it does not have to be that way.
For example, the SmaCC tutorial shows a calculator. 
This calculator does not produce a parse tree; the result is interpreted on the fly.
</p>

<h3>Production Rules</h3>

<p>
The production rules contains the grammar for the parser.
The first production rule is considered to be the starting rule for the parser.
Each production rule consists of a non-terminal symbol name followed by a &quot;:&quot; separator which is followed by a list of possible productions separated by vertical bar, &quot;|&quot;, and finally terminated by a semicolon, &quot;;&quot;.
</p>
<figure><pre><code>Expression 
	: Expression 'left' &quot;+&quot; 'operator' Expression 'right' {{Binary}}
	| Expression 'left' &quot;-&quot; 'operator' Expression 'right' {{Binary}}
	| Expression 'left' &quot;*&quot; 'operator' Expression 'right' {{Binary}}
	| Expression 'left' &quot;/&quot; 'operator' Expression 'right' {{Binary}}
	| Expression 'left' &quot;^&quot; 'operator' Expression 'right' {{Binary}}
	| &quot;(&quot; Expression &quot;)&quot; {{}}
	| Number
	;
Number 
	: &lt;number&gt; {{Number}}
	;</code></pre><figcaption></figcaption></figure>

<p>
Each production consists of a sequence of non-terminal symbols, tokens, or keywords followed by some optional Smalltalk code enclosed in curly brackets, {} or an AST node definition enclosed in two curly brackets, {{}}.
Non-terminal symbols are valid Smalltalk variable names and must be defined somewhere in the parser definition.
Forward references are valid.
Tokens are enclosed in angle brackets as they are defined in the scanner (e.g., &lt;token&gt;) and keywords are enclosed in double-quotes (e.g., &quot;then&quot;).
Keywords that contain double-quotes need to have two double-quotes per each double-quote in the keyword.
For example, if you need a keyword for one double-quote character, you would need to enter &quot;&quot;&quot;&quot; (four double-quote characters).
</p>
<p>
The Smalltalk code is evaluated whenever that production is matched.
If the code is a zero or a one argument symbol, then that method is performed.
For a one argument symbol, the argument is an OrderedCollection that contains one element for each item in the production.
If the code isn't a zero or one argument symbol, then the code is executed and whatever is returned by the code is the result of the production.
If no Smalltalk code is specified, then the default action is to execute the #reduceFor: method (unless you are producing an AST parser).
This method converts all items into an OrderedCollection.
If one of the items is another OrderedCollection, then all of its elements are added to the new collection.
</p>
<p>
Inside the Smalltalk code you can refer to the values of each production item by using literal strings.
The literal string, '1', refers to the value of the first production item.
The values for tokens and keywords will be SmaCCToken objects.
The value for all non-terminal symbols will be whatever the Smalltalk code evaluates to for that non-terminal symbol.
</p>

<h3>Named Symbols</h3>

<p>
When entering the Smalltalk code, you can get the value for a symbol by using the literal strings (e.g., '2').
However, this creates difficulties when modifying a grammar.
If you insert some symbol at the beginning of a production, then you will need to modify your Smalltalk code changing all literal string numbers.
Instead you can name each symbol in the production and then refer to the name in the Smalltalk code.
To name a symbol (non-terminal, token, or keyword), you need to add a quoted variable name after the symbol in the grammar.
For example, &quot;MySymbol : Expression 'expr' &quot;+&quot; &lt;number&gt; 'num' {expr + num} ;&quot; creates two named variables: one for the non-terminal Expression and one for the &lt;number&gt; token.
These variables are then used in the Smalltalk code.
</p>

<h3>Error Recovery</h3>

<p>
Normally, when the parser encounters an error, it raises the SmaCCParserError exception and parsing is immediately stopped.
However, there are times when you may wish to try to parse more of the input.
For example, if you are highlighting code, you do not want to stop highlighting at the first syntax error.
Instead you may wish to attempt to recover after the statement separator -- the period &quot;.&quot;.
SmaCC uses the error symbol to specify where error recovery should be attempted.
For example, we may have the following rule to specify a list of Smalltalk statements:
</p>
<figure><pre><code>Statements : Expression | Statements &quot;.&quot; Expression ;</code></pre><figcaption></figcaption></figure>

<p>
If we wish to attempt recovery from a syntax error when we encounter a period, we can change our rule to be:
</p>
<figure><pre><code>Statements : Expression | Statements &quot;.&quot; Expression | error &quot;.&quot; Expression ;</code></pre><figcaption></figcaption></figure>

<p>
While the error recovery allows you to proceed parsing after a syntax error, it will not allow you to return a parse tree from the input.
Once the input has been parsed with errors, it will raise a non-resumable SmaCCParserError.
</p>
<h3>Shortcuts</h3>
<a id="sec:shortcuts"></a>
<p>
Extended BNF grammars extend the usual notation for grammar productions with some convenient shortcuts.
SmaCC supports the common notations of Kleene star (<code>*</code>) for 0 or more, question mark (<code>?</code>) for 0 or 1, and Kleene plus (<code>+</code>) for 1 or more repetitions of the preceding item.
For example, rather than specifying a <code>ParameterList</code> in the conventional way, like this
</p>
<figure><pre><code>&lt;name&gt; : [a-zA-Z] [a-zA-Z0-9_']* ;
&lt;whitespace&gt;: \s+ ;

ParameterList
	: Parameter
	| ParameterList Parameter
	;
	
Parameter
	: &lt;name&gt;
	;</code></pre><figcaption></figcaption></figure>

<p>
we can be more concise and specify it like this:
</p>
<figure><pre><code>&lt;name&gt; : [a-zA-Z] [a-zA-Z0-9_']* ;
&lt;whitespace&gt;: \s+ ;

ParameterList
	: Parameter +
	;
	
Parameter
	: &lt;name&gt;
	;</code></pre><figcaption></figcaption></figure>

<p>
If we are generating an AST, these shortcuts have the aditional advantage of producing more compact AST nodes.
For more information, see the Chapter on <a href="Chapters/Smacc/./SmaccIdioms.html#cha:idioms">Idioms</a>.

</p>
<h2>SmaCC Directives</h2>

<p>
SmaCC has several directives that can change how the scanner and parser is generated.
Each directive begins with a <code>%</code> character and the directive keyword.
Depending on the directive, there may be a set of arguments.
Finally, the directive is terminated with a semicolon character, <code>;</code> as shown below:
</p>
<figure><pre><code>%left &quot;+&quot; &quot;-&quot;;
%left &quot;*&quot; &quot;/&quot;;
%right &quot;^&quot;;
%annotate_tokens;
%root Expression;
%prefix AST;
%suffix Node;
%ignore_variables leftParenToken rightParenToken;</code></pre><figcaption></figcaption></figure>


<h3>Start Symbols</h3>

<p>
By default, the left-hand side of the first grammar rule is the start symbol.
If you want to multiple start symbols, you can specify them by using the <code>%start</code> directive followed by the nonterminals that are additional start symbols. 
This is useful for creating two parsers with grammars that are similar but slightly different.
For example, consider a Pharo parser.
You can parse methods, and you can parse expressions.
These are two different operations, but have similar grammars.
Instead of creating two different parsers for parsing methods and expressions, we can specify one grammar that parses methods, and also specify an alternative start symbol for parsing expressions.
</p>
<p>
The <code>StParser</code> in the SmaCC Example Parsers package has an example of this.
The method <code>StParser class&gt;&gt;parseMethod:</code> uses the <code>startingStateForMethod</code> position to parse methods and the method <code>StParser class&gt;&gt;parseExpression:</code> uses the <code>startingStateForSequenceNode</code> position to parse expressions.
</p>
<p>
For example if you add the following to an hypothetical grammar:
</p>
<figure><pre><code>%start file expression statement declaration;</code></pre><figcaption></figcaption></figure>

<p>
SmaCC will generate the following class methods on the parser: <code>startingStateForfile</code>, <code>startingStateForexpression</code>, <code>startingStateForstatement</code> and <code>startingStateFordeclaration</code>.
Then you can parse a subpart as follows:
</p>
<figure><pre><code>YourParser &gt;&gt; parseStatement: aString
	&quot;Parse an statement.&quot;

	^ (self on: (ReadStream on: aString))
		setStartingState: self startingStateForstatement;
		parse</code></pre><figcaption></figcaption></figure>

<p>
The ability to specify multiple start symbols is useful when you build your grammar incrementally.
You might also want to create additionnal start symbols to test grammar features independently.
</p>

<h3>Id Methods</h3>

<p>
Internally, the various token types are represented as integers.
However, there are times when you need to reference the token types.
For example, in the CScanner and CParser classes, the <code>TYPE_NAME</code> token has a syntax identical in the IDENTIFIER token.
To distinguish them, the IDENTIFIER matching method does a lookup in the type table: if it finds a type definition with the same name as the current IDENTIFIER, it returns the TYPE_NAME token type.
To determine what integer this is, the parser includes an <code>%id</code> directive for &lt;IDENTIFIER&gt; and &lt;TYPE_NAME&gt;.
This generates the IDENTIFIERId and TYPE_NAMEId methods on the scanner.
These methods simply return the integer representing that token type.
See the C sample scanner and parser for an example of how the <code>%id</code> directive is used.
</p>

<h3>Case Insensitive Scanning</h3>

<p>
You can specify that the scanner should ignore case differences by using the <code>%ignorecase;</code> directive.
If you have a language that is case insensitive and has several keywords, this can be a handy feature.
For example, if you have <code>THEN</code> as a keyword in a case insensitive language, you would need to specify the token for then as <code>&lt;then&gt; : [tT] [hH] [eE] [nN] ;</code>.
This is a pain to enter correctly.
When the ignorecase directive is used, SmaCC will automatically convert <code>THEN</code> into <code>[tT][hH][eE][nN]</code>.
</p>

<h3>AST Directives</h3>

<p>
There are several directives that are used when creating AST's. 
</p>
<p>
The <code>%root</code> directive is used to specify the root class in the AST hierarchy.
The <code>%root</code> directive has a single argument that is the name that will be used to create the root class in the AST.
This class will be created as a subclass of <code>SmaCCParseNode</code>.
</p>
<p>
The <code>%prefix</code> and <code>%suffix</code> directives tell SmaCC the prefix and suffix to add to create the node name for the AST node's class.
This prefix and suffix are added to the name of every AST node, including the %root node.
For example, the following will create a <code>RBProgramNode</code> class that is a subclass of <code>SmaCCParseNode</code> and is the root of all AST nodes defined by this parser.
</p>
<figure><pre><code>%root Program;
%prefix RB;
%suffix Node;</code></pre><figcaption></figcaption></figure>

<p>
By default all nodes created by SmaCC will be direct subclass of your <code>%root class</code>.
However, you can specify the class hierarchy by using the <code>%hierarchy</code> directive.
The syntax of the <code>%hierarchy</code> is <code>%hierarchy SuperclassName &quot;(&quot; SubclassName + &quot;);&quot;</code>.
If you have multiple subclasses, you can list all of them inside the parenthesis, separated by whitespace, as follows.
</p>
<figure><pre><code>%hierarchy Program (Expression Statement);</code></pre><figcaption></figcaption></figure>

<p>
Three AST directives deal with the generated classes' instance variables.
</p>
<p>
The <code>%annotate_tokens</code> tells SmaCC to generate instance variable names for any unnamed tokens in the grammar rules.
Without this directive, an unnamed token will generate the warning:
</p>
<figure><pre><code>Unnamed symbol in production. Without a variable name the value will be dropped from the parsed AST.&quot;</code></pre><figcaption></figcaption></figure>

<p>
With the directive, a variable name will be auto-generated, using the name of the symbol follwed by <code>Token</code>.
So the symbol <code>&lt;op&gt;</code> would be given the name <code>&lt;opToken&gt;</code>.
</p>

<p>
The <code>%attributes</code> directive allows you to add some extra instance variables to your classes.
This enables you to later extend the generated classes to use those variables.
The first argument to the <code>%attributes</code> directive is the node name (without the prefix and suffix); the second argument is a parenthesised list of variable names.
For example, we could add an instance variable <code>cachedValue</code> to the <code>Expression</code> class with <code>%attributes Expression (cachedValue);</code>.
</p>
<p>
Note that if you do not use this directive, but simply add the instance variables to the classes by hand, SmaCC will remove them the next time that the classes are re-generated.
Then your instance variables will become undeclared, and any code that uses them will start to behave unexpectedly.
This can be the explanation for unexplained and inconsistent behaviour.
</p>

<p>
The final instance variable directive is <code>%ignore_variables</code>. 
When SmaCC creates the AST node classes, it automatically generates appropriate <code>=</code> and <code>hash</code> methods.
By default, these methods use all instance variables when comparing for equality and computing the hash.
The <code>%ignore_variables</code> directive allows you to specify that certain variables should be ignored.
For example, you may wish to ignore parentheses when you compare expressions.
If you named your <code>(</code> token 'leftParen' and your <code>)</code> token 'rightParen', then you can specify this with <code>%ignore_variables leftParen rightParen;</code>.
</p>

<h3>Dealing with Ambiguous Grammars</h3>

<p>
An ambiguity occurs in a grammar when for a single lookahead token, the parser can execute two or more different actions.
Which one should the parser choose?
</p>
<p>
In traditionnal LR parsing, there are two types of conflicts between two actions that can occur: reduce/reduce and shift/reduce.
A reduce/reduce conflict exists when the parser can either reduce using one rule in the grammar or reduce using another rule.
A shift/reduce conflict exists when the parser can either shift the current lookahead token or reduce using a given rule.
</p>

<h4>LR, LALR and Ambiguous Grammars</h4>

<p>
When a LR or LALR parser is generated from an ambiguous grammar, conflicts will be displayed in the &quot;Message&quot; box.
The resulting parser will choose an arbitrary action to execute between the ones available.
Since it not a behaviour you usually want, you have several options: 
</p><ul>
<li>rewrite the grammar to be unambiguous,</li>
<li>hack in the parser/scanner to resolve the conflict,</li>
<li>use precedence rules to remove the confict (see section <a href="#PrecedenceRules"></a>),</li>
<li>switch to GLR parsing (see section <a href="#GLR"></a>).</li>
</ul>

<p>
The last two options will be detailed in the following sections.
</p>

<h4>Precedence Rules</h4>
<a id="PrecedenceRules"></a>
<p>
When SmaCC encounters a shift/reduce conflict it will perform the shift action by default.
However, you can control this action with the <code>%left</code>, <code>%right</code>, and <code>%nonassoc</code> directives.
If a token has been declared in a <code>%left</code> directive, it means that the token is left-associative.
Therefore, the parser will perform a reduce operation.
However, if it has been declared as right-associative, it will perform a shift operation.
A token defined as <code>%nonassoc</code> will produce an error if that is encountered during parsing.
For example, you may want to specify that the equal operator, &quot;=&quot;, is non-associative, so <code>a = b = c</code> is not parsed as a valid expression.
All three directives are followed by a list of tokens.
</p>
<p>
Additionally, the <code>%left</code>, <code>%right</code>, and <code>%nonassoc</code> directives allow precedence to be specified.
The order of the directives specifies the precedence of the tokens.
The higher precedence tokens appear on the higher line numbers.
For example, the following directive section gives the precedence for the simple calculator in our tutorial:
</p>
<figure><pre><code>%left &quot;+&quot; &quot;-&quot;;
%left &quot;*&quot; &quot;/&quot;;
%right &quot;^&quot;;</code></pre><figcaption></figcaption></figure>

<p>
The symbols <code>+</code> and <code>-</code> appear on the first line, and hence have the lowest precedence.
They are also left-associative, so <code>1 + 2 + 3</code> will be evaluated as <code>(1 + 2) + 3</code>.
On the next line we see the symbols <code>*</code> and <code>/</code>; since they appear on a line with a higher line number, they have higher precedence than <code>+</code> and <code>-</code>.
Finally, on line three we have the <code>^</code> symbol.
It has the highest precedence, but is <em>right</em> associative.
Combining all the rules allows us to parse <code>1 + 2 * 3 / 4 ^ 2 ^ 3</code> as <code>1 + ((2 * 3) / (4 ^ (2 ^ 3)))</code>.
</p>

<h4>GLR Parsing</h4>
<a id="GLR"></a>
<p>
SmaCC allows you to parse ambiguous grammars using a GLR parser.
The <code>%glr;</code> directive changes the type of parser that SmaCC generates (you can also used <code>%parser glr;</code>).
Instead of your generated parser being a subclass of <code>SmaCCParser</code>, when you use the <code>%glr;</code> directive, your parser will be a subclass of SmaCCGLRParser.
</p>
<p>
If you parse a string that has multiple representations, SmaCC will throw a <code>SmaCCAmbiguousResultNotification</code> exception, which can be handled by user code.
This exception has the potential parses.
The value with which it is resumed with will be selected as the definitive parse value.
If the exception is not handled, then SmaCC will pick one as the definitive parse value.
</p>
<p>
To handle all the ambiguities of a program, the GLR parser performs multiple parses in parallel.    
No individual parse backtracks, but when switching between parses the scanner may backtrack.                   
To support this, the scanner implements the methods <code>currentState</code> (which reifies the scanner's state into an object) and <code>restoreState:</code> (which expects as its parameter an object produced by <code>currentState</code>).
If you have added instance variables to your scanner, then you will need to override these two methods to save and restore your instance variables.                                                                   
The same is true for the parser: you can save and restore its state using the <code>duplicateState</code> and <code>restoreState:</code> methods respectively.
Be sure to override those methods if you have special instance variables in your parser.
</p>
<p>
If you have overlapping tokens, and have overridden the method <code>tryAllTokens</code> to return <code>true</code>, then in a GLR parser, SmaCC will try to perform a separate parse with each possible interpretation of the token.
In this case, SmaCC may defer a parser action until it has decided which interpretation to pursue.
Normally, this deferral will not be noticeable, but if the parser actions affect the scanner state, the scanner's behaviour will be changed.
This is likely to happen if your scanner has multiple states.
</p>

<h2>SmaCC Abstract Syntax Trees</h2>
<a id="AST"></a>
<p>
SmaCC can generate abstract syntax trees from an annotated grammar.
In addition to the node classes to represent the trees, SmaCC also generates a generic visitor for the tree classes.
This is handy and boost your productivity especially since you can decide to change the AST structure afterwards and get a new one in no time.
</p>
<h3>Restarting</h3>

<p>
To create an AST, you need to annotate your grammar.
Let's start with the grammar of our simple expression parser from the tutorial.
Since we want to build an AST, we've removed the code that evaluates the expression.
</p>
<figure><pre><code>&lt;number&gt; : [0-9]+ (\. [0-9]*) ? ;
&lt;whitespace&gt; : \s+;

%left &quot;+&quot; &quot;-&quot;;
%left &quot;*&quot; &quot;/&quot;;
%right &quot;^&quot;;

Expression 
	: Expression &quot;+&quot; Expression 
	| Expression &quot;-&quot; Expression
	| Expression &quot;*&quot; Expression
	| Expression &quot;/&quot; Expression
	| Expression &quot;^&quot; Expression
	| &quot;(&quot; Expression &quot;)&quot;
	| Number
	;
Number 
	: &lt;number&gt;
	;</code></pre><figcaption></figcaption></figure>


<h3>Building Nodes </h3>

<p>
Building an AST-building parser works similarly to the normal parser.
Instead of inserting Pharo code after each production rule inside braces, <code>{}</code>, we insert the class name inside of double braces, <code>{{}}</code>.
Also, instead of naming a variable for use in the Pharo code, we name a variable so that it will be included as an instance variable in the node class we are defining.
</p>
<p>
Let's start with annotating the grammar for the AST node classes that we wish to parse.
We need to tell SmaCC where the AST node should be created and the name of the node's class to create.
In our example, we'll start by creating three node classes: Expression, Binary, and Number.
</p>
<figure><pre><code>&lt;number&gt; : [0-9]+ (\. [0-9]*) ? ;
&lt;whitespace&gt; : \s+;

%left &quot;+&quot; &quot;-&quot;;
%left &quot;*&quot; &quot;/&quot;;
%right &quot;^&quot;;

Expression 
	: Expression &quot;+&quot; Expression {{Binary}}
	| Expression &quot;-&quot; Expression {{Binary}}
	| Expression &quot;*&quot; Expression {{Binary}}
	| Expression &quot;/&quot; Expression {{Binary}}
	| Expression &quot;^&quot; Expression {{Binary}}
	| &quot;(&quot; Expression &quot;)&quot; {{}}
	| Number
	;
Number 
	: &lt;number&gt; {{Number}}
	;</code></pre><figcaption></figcaption></figure>

<p>
If you compile this grammar, SmaCC will complain that we need to define a root node.
Since the root has not been defined, SmaCC compiles the grammar as if the <code>{{...}}</code> expressions where not there and generates the same parser as above. 
</p>
<ul>
<li>Notice that for the parenthesized expression, we are using <code>{{}}</code>. This is a shortcut for the name of our production symbol (here, <code>{{Expression}}</code>). </li>
<li>Notice that we didn't annotate the last production in the Expression definition. Since it only contains a single item, Number, SmaCC will pull up its value which in this case will be a Number AST node.</li>
</ul>


<h3>Variables and Unnamed Entities</h3>

<p>
Now, let's add variable names to our rules:
</p>
<figure><pre><code>&lt;number&gt; : [0-9]+ (\. [0-9]*) ? ;
&lt;whitespace&gt; : \s+;

%left &quot;+&quot; &quot;-&quot;;
%left &quot;*&quot; &quot;/&quot;;
%right &quot;^&quot;;
%annotate_tokens;

Expression 
	: Expression 'left' &quot;+&quot; 'operator' Expression 'right' {{Binary}}
	| Expression 'left' &quot;-&quot; 'operator' Expression 'right' {{Binary}}
	| Expression 'left' &quot;*&quot; 'operator' Expression 'right' {{Binary}}
	| Expression 'left' &quot;/&quot; 'operator' Expression 'right' {{Binary}}
	| Expression 'left' &quot;^&quot; 'operator' Expression 'right' {{Binary}}
	| &quot;(&quot; Expression &quot;)&quot; {{}}
	| Number
	;
Number 
	: &lt;number&gt; {{Number}}
	;</code></pre><figcaption></figcaption></figure>

<p>
The first thing to notice is that we added the <code>%annotate_tokens;</code> directive.
This directive tells SmaCC to automatically create an instance variable for every unnamed token and keyword in the grammar.
An unamed token is a <code>&lt;&gt;</code> not followed by a variable (defined with <code>'aVariable'</code>) and an unnamed keyword is delimited by double quotes as in <code>&quot;(&quot;</code>.
</p>
<p>
In our example above, we have:
</p><ul>
<li>one unnamed token, <code>&lt;number&gt;</code>, and </li>
<li>two unnamed keywords, <code>(</code> and <code>)</code>. </li>
</ul>

<p>
When SmaCC sees an unnamed token or keyword, it adds a variable that is named based on the item and appends Token to the name.
For example, in our example above, SmaCC will use:
</p><ul>
<li>leftParenToken for <code>(</code>, </li>
<li>rightParenToken for <code>)</code>, and </li>
<li><code>numberToken</code> for <code>&lt;number&gt;</code>. </li>
</ul>

<p>
The method <code>SmaCCGrammar class&gt;&gt;tokenNameMap</code> contains the mapping to convert the keyword characters into valid Pharo variable names.
You can modify this dictionary if you wish to change the default names.
</p>

<h3>Unnamed Symbols</h3>

<p>
Notice that we did not name Expression in the <code>(</code> Expression <code>)</code> production rule.
When you don't name a symbol in a production, SmaCC tries to figure out what you want to do.
In this case, SmaCC determines that the Expression symbol produces either a Binary or Number node.
Since both of these are subclasses of the Expression, SmaCC will pull up the value of Expression and add the parentheses to that node.
So, if you parse <code>(3 + 4)</code>, you'll get a Binary node instead of an Expression node.
</p>

<h3>Generating the AST</h3>

<p>
Now we are ready to generate our AST.
We need to add directives that tell SmaCC our root AST class node and the prefix and suffix of our classes.
</p>
<figure><pre><code>&lt;number&gt; : [0-9]+ (\. [0-9]*) ? ;
&lt;whitespace&gt; : \s+;

%left &quot;+&quot; &quot;-&quot;;
%left &quot;*&quot; &quot;/&quot;;
%right &quot;^&quot;;

%annotate_tokens;
%root Expression;
%prefix AST;
%suffix Node;

Expression 
	: Expression 'left' &quot;+&quot; 'operator' Expression 'right' {{Binary}}
	| Expression 'left' &quot;-&quot; 'operator' Expression 'right' {{Binary}}
	| Expression 'left' &quot;*&quot; 'operator' Expression 'right' {{Binary}}
	| Expression 'left' &quot;/&quot; 'operator' Expression 'right' {{Binary}}
	| Expression 'left' &quot;^&quot; 'operator' Expression 'right' {{Binary}}
	| &quot;(&quot; Expression &quot;)&quot; {{}}
	| Number
	;
Number 
	: &lt;number&gt; {{Number}}
	;</code></pre><figcaption></figcaption></figure>

<p>
When you compile this grammar, in addition to the normal parser and scanner classes, SmaCC will create <code>ASTExpressionNode</code>, <code>ASTBinaryNode</code>, and <code>ASTNumberNode</code> node classes and an <code>ASTExpressionNodeVisitor</code> class that implements the visitor pattern for the tree classes.
</p>
<p>
The <code>ASTExpressionNode</code> class will define two instance variables, <code>leftParenTokens</code> and <code>rightParenTokens</code>, that will hold the <code>(</code> and <code>)</code> tokens.
Notice that these variables hold a collection of tokens instead of a single parenthesis token.
SmaCC figured out that each expression node could contain multiple parentheses and made their variables hold a collection.
Also, it pluralized the <code>leftParentToken</code> variable name to <code>leftParenTokens</code>.
You can customize how it pluralizes names in the <code>SmaCCVariableDefinition</code> class (See <code>pluralNameBlock</code> and <code>pluralNames</code>).
</p>
<p>
The <code>ASTBinaryNode</code> will be a subclass of <code>ASTExpressionNode</code> and will define three variables: <code>left</code>, <code>operator</code>, and <code>right</code>. 
</p><ul>
<li>The <code>left</code> and <code>right</code> instance variables will hold other <code>ASTExpressionNodes</code> and </li>
<li>the <code>operator</code> instance variable will hold a token for the operator. </li>
</ul>

<p>
Finally, the <code>ASTNumberNode</code> will be a subclass of <code>ASTExpressionNode</code> and will define a single instance variable, <code>number</code>, that holds the token for the number.
</p>
<p>
Now, if we inspect the result of parsing <code>3 + 4</code>, we'll get an Inspector on an <code>ASTBinaryNode</code>.
</p>

<h3>AST Comparison</h3>

<p>
SmaCC also generates the comparison methods for each AST node.
Let's add function evaluation to our expression grammar to illustrate this point.
</p>
<figure><pre><code>&lt;number&gt; : [0-9]+ (\. [0-9]*) ? ;
&lt;name&gt; : [a-zA-Z]\w*;
&lt;whitespace&gt; : \s+;

%left &quot;+&quot; &quot;-&quot;;
%left &quot;*&quot; &quot;/&quot;;
%right &quot;^&quot;;
%annotate_tokens;
%root Expression;
%prefix AST;
%suffix Node;

Expression 
	: Expression 'left' &quot;+&quot; 'operator' Expression 'right' {{Binary}}
	| Expression 'left' &quot;-&quot; 'operator' Expression 'right' {{Binary}}
	| Expression 'left' &quot;*&quot; 'operator' Expression 'right' {{Binary}}
	| Expression 'left' &quot;/&quot; 'operator' Expression 'right' {{Binary}}
	| Expression 'left' &quot;^&quot; 'operator' Expression 'right' {{Binary}}
	| &quot;(&quot; Expression &quot;)&quot; {{}}
	| Number
	| Function
	;
Number 
	: &lt;number&gt; {{Number}}
	;
Function
	: &lt;name&gt; &quot;(&quot; 'leftParen' (Expression 'argument' (&quot;,&quot; Expression 'argument')* )? &quot;)&quot; 'rightParen' {{}}
	;</code></pre><figcaption></figcaption></figure>

<p>
Now, if we inspect <code>Add(3, 4)</code>, we will get something that looks like an <code>ASTFunctionNode</code>.
</p>
<p>
In addition to generating the node classes, SmaCC also generates the comparison methods for each AST node.
For example, we can compare two parse nodes: <code>(CalculatorParser parse: '3 + 4') = (CalculatorParser parse: '3+4')</code>.
This returns true as whitespace is ignored.
However, if we compare <code>(CalculatorParser parse: '(3 + 4)') = (CalculatorParser parse: '3+4')</code>, we get false, since the first expression has parentheses.
We can tell SmaCC to ignore these by adding the <code>%ignore_variables</code> directive.
</p>
<figure><pre><code>&lt;number&gt; : [0-9]+ (\. [0-9]*) ? ;
&lt;name&gt; : [a-zA-Z]\w*;
&lt;whitespace&gt; : \s+;

%left &quot;+&quot; &quot;-&quot;;
%left &quot;*&quot; &quot;/&quot;;
%right &quot;^&quot;;
%annotate_tokens;
%root Expression;
%prefix AST;
%suffix Node;
%ignore_variables leftParenToken rightParenToken;

Expression 
	: Expression 'left' &quot;+&quot; 'operator' Expression 'right' {{Binary}}
	| Expression 'left' &quot;-&quot; 'operator' Expression 'right' {{Binary}}
	| Expression 'left' &quot;*&quot; 'operator' Expression 'right' {{Binary}}
	| Expression 'left' &quot;/&quot; 'operator' Expression 'right' {{Binary}}
	| Expression 'left' &quot;^&quot; 'operator' Expression 'right' {{Binary}}
	| &quot;(&quot; Expression &quot;)&quot; {{}}
	| Number
	| Function
	;
Number 
	: &lt;number&gt; {{Number}}
	;
Function
	: &lt;name&gt; &quot;(&quot; 'leftParen' (Expression 'argument' (&quot;,&quot; Expression 'argument')* )? &quot;)&quot; 'rightParen' {{}}
	;</code></pre><figcaption></figcaption></figure>

<p>
Now, we get true when we compare <code>(CalculatorParser parse: '(3 + 4)') = (CalculatorParser parse: '3+4')</code>.
</p>

<h3>Extending the Visitor</h3>

<p>
Finally, let's subclass the generated visitor to create a visitor that evaluates the expressions.
Here's the code for Pharo:
</p>
<figure><pre><code>ASTExpressionNodeVisitor subclass: #ASTExpressionEvaluator
	instanceVariableNames: 'functions'
	classVariableNames: ''
	package: 'SmaCC-Tutorial'.</code></pre><figcaption></figcaption></figure>

<figure><pre><code>ASTExpressionEvaluator &gt;&gt; functions
	^functions
		ifNil: 
			[functions := (Dictionary new)
						at: ''Add'' put: [:a :b | a + b];
						yourself ]' classified: 'private'.</code></pre><figcaption></figcaption></figure>


<figure><pre><code>ASTExpressionEvaluator &gt;&gt; visitBinary: aBinary
	| left right operation |
	left := self acceptNode: aBinary left.
	right := self acceptNode: aBinary right.
	operation := aBinary operator value.
	operation = ''^'' ifTrue: [ ^left ** right ].
	^left perform: operation asSymbol with: right' classified: 'visiting'.</code></pre><figcaption></figcaption></figure>

<figure><pre><code>ASTExpressionEvaluator &gt;&gt; visitFunction: aFunction
	| function arguments |
	function := self functions at: aFunction nameToken value
				ifAbsent: 
					[self error: ''Function '' , 
						aFunction nameToken value , 
						'' is not defined'' ].
	arguments := aFunction arguments collect: [ :each | self acceptNode: each ].
	^function valueWithArguments: arguments asArray classified: 'visiting'.</code></pre><figcaption></figcaption></figure>

<figure><pre><code>ASTExpressionEvaluator &gt;&gt; visitNumber: aNumber
	^ aNumber numberToken value asNumber' classified: 'visiting'.</code></pre><figcaption></figcaption></figure>

<p>
Now we can evaluate <code>ASTExpressionEvaluator new accept: (CalculatorParser parse: 'Add(3,4) * 12 / 2 ^ (3 - 1) + 10')</code> and get 31.

</p>
<h2>Advanced Features of SmaCC</h2>

<p>
This chapter addresses the problem of parsing a language with two interesting features:
string interpolations and indentation.
SmaCC can handle both, but doing so requires that we use some more advanced techniques.
To deal with string interpolations we will use a scanner with multiple states; to deal with indentation will will add some custom token actions to the scanner.
Lets look at these techniques one at a time.
</p>

<h3>Multi-state Scanners</h3>

<p>
To motivate the need for a multi-state scanner, let's look at a feature of the Grace programming language: string interpolations.
Similar features are available in many other languages, including JavaScript and Scala.
</p>
<p>
In Grace, a <code>StringLiteral</code> is a sequence of characters enclosed by double quotes; 
a <code>StringConstructor</code> is like a string literal, but can also contain Grace expressions surrounded by braces.
Here is an example.
</p>
<figure><pre><code>&quot;the value of count is {count}.&quot;</code></pre><figcaption></figcaption></figure>

<p>
The value of this string is determined by evaluating the variable <code>count</code>, converting the answer to a string (by sending it the <code>asString</code> message), 
and interpolating the resulting string in place of the brace expression.
So, if <code>count</code> is <code>19</code>, the final value of the constructed string will be:
</p>
<figure><pre><code>&quot;the value of count is 19.&quot;</code></pre><figcaption></figcaption></figure>

<p>
If the expressions between braces were restricted to simple identifiers, this would pose no problem for the scanner.
However the Grace language allows arbitrary code to appear between the braces.
Such code can contain matched string quotes and matched pairs of braces.
(In Grace, outside of strings, braces are used to enclose blocks, i.e., they mean roughly the same as brackets in Smalltalk.)
</p>
<p>
If you remember your formal language theory, you will know that the language of properly nested parentheses is not regular.
So we cannot write simple regular expressions in the scanner that will correctly tokenize this language.
In essence, the problem is that a regular expression, (or, more precisely, the finite state automaton that recognizes the language defined by that expression) can't maintain an unbounded counter.
What should we do?
</p>
<p>
SmaCC lets us solve this problem by building a scanner with two separate âstatesâ: a special state for scanning strings, and a default state for the rest of the language.
We declare the <code>string</code> state as follows:
</p>
<figure><pre><code>%states string ;</code></pre><figcaption></figcaption></figure>

<p>
The default state does not need to be declared explicitly.
</p>
<p>
Scanner rules prefixed with the name of a state operate only in that state.
For example:
</p>
<figure><pre><code>string &lt;stringSegment&gt; : ( [^\&quot;\{\\\x00-\x1F] | \xA0 | \\[nt\{\}\\\] ) + ;</code></pre><figcaption></figcaption></figure>

<p>
defines a <code>&lt;stringSegment&gt;</code> as one or more characters, <em>excluding</em> the double-quote, open-brace, backslash, or any of the control characters between <code>0</code> and hex <code>1F</code>, or the non-breaking space hex <code>A0</code>, or one of the backslash escapes n, t, {, }, &quot;, r, l, _ and \.
However, this definition operates only in the <em>string</em> state, which stops it from matching, for example, identifiers.
Similarly, identifiers and whitespace are recognized only in the <code>default</code> state (which stops them for matching the content of a string).
We want double-quotes (which delimit strings) to be recognized in both states, so we prefix that rule with both names.
</p>
<figure><pre><code>default &lt;id&gt; : [a-zA-Z_] [a-zA-Z0-9_'] * ;
default &lt;whitespace&gt;: ( \x20 | \xA0 ) + ;
default string &lt;dquote&gt;:  [&quot;] ;</code></pre><figcaption></figcaption></figure>

<p>
What remains is to switch the scanner into the <code>string</code> state when an opening string quote is encountered.
Then it needs to switch back to the <code>default</code> state either when it finds either the closing string quote, or an opening brace.
How can we achieve this?
</p>
<p>
One possibility is to write custom token methods in the scanner, which might count opening and closing braces and determine when the brace that closes the interpolation has been found.
But there is a better solution, which takes advantage of the fact that SmaCC does not run the scanner and parser as separate passes.
Instead, the parser calls the scanner when, and only when, the parser needs the next token.
</p>
<p>
Here are the parser rules that change the scanner state:
</p>
<figure><pre><code>StartString
    : { self state: #string. ^ nil }
    ;
RetDefault
    : { self state: #default. ^ nil }
    ;</code></pre><figcaption></figcaption></figure>

<p>
These rules both match the empty input, so they don't actually parse anything.
Their only function is to force parser actions to be executed.
The non-terminals that they define are used in the rules for <code>StringLiteral</code> and <code>StringConstructor</code>.
</p>
<figure><pre><code>StringLiteral
    : StartString &lt;dquote&gt; &lt;stringSegment&gt; ? RetDefault &lt;dquote&gt;
    ;
StringConstructor
    : StartString &lt;dquote&gt; &lt;stringSegment&gt; ? ( RetDefault &quot;{&quot; Expression StartString &quot;}&quot; &lt;stringSegment&gt; ? ) + RetDefault &lt;dquote&gt;
    ;</code></pre><figcaption></figcaption></figure>

<p>
The first rule says that a <code>StringLiteral</code> starts with a <code>&lt;dquote&gt;</code> token, which is followed by an optional <code>&lt;stringSegment&gt;</code>, and a closing <code>&lt;dquote&gt;</code>.
The initial <code>StartString</code> non-terminal can be thought of as a âcallâ of the <code>StartString</code> parser action, which, as we saw above, sets the scanner state to <code>string</code>.
This action won't be executed until <em>after</em> the next token (<code>&lt;dquote&gt;</code>) is scanned, but when <code>&lt;stringSegment&gt;</code> is scanned,
the scanner will be in state <code>string</code>, and thus the scanner rule for <code>&lt;stringSegment&gt;</code> will be applied.
Similarly, after the end of the <code>&lt;stringSegment&gt;</code>, the <code>RetDefault</code> action will return the scanner to the <em>default</em> state.
This won't happen until <em>after</em> the <code>&lt;dquote&gt;</code> is scanned, but since the rule for <code>&lt;dquote&gt;</code> is valid in both the default state and the string state, that's OK.
</p>
<p>
The rule for <code>StringConstructor</code> is a bit more complicated, and it's for this one that we really need multiple states.
This rule allows multiple interpolations enclosed between braces.
The <code>RetDefault</code> production is used to return the scanner to the <em>default</em> state before each opening brace.
Then the <code>StartString</code> production is used to return it to the <em>string</em> state at the closing brace that marks the end of the interpolation.
Once again, because of the way that the parser works, there is a one token âdelayâ before the state-change takes effect.
This is because the parser won't execute an action until the <em>next</em> token has been read, and the parser has determined that a reduce action is appropriate.
</p>
<p>
The overall effect is as if there were two different scanners: one for strings, and one for the rest of the source program.
The appropriate scanner is used for each part of the input, without further effort.
</p>

<h3>Indentation-Sensitive Parsing</h3>

<p>
In many languages, the layout of the source code matters.
Some languages, like Haskell and Python, use layout to indicate the start and end of code blocks.
A common way to describe the syntax of such languages is to imagine a pre-pass over the input that examines the layout and inserts <em>indent</em> and <em>outdent</em> tokens whenever the indentation changes.
The grammar of the language is then written in terms of these tokens.
Grace is somewhat simpler than Haskell and Python in that its code blocks are delimited by <code>{</code> braces <code>}</code>.
It is similar, though, in that it requires the body of a code block to be indented more than the surrounding code.
How can we enforce a rule like this using SmaCC?
</p>

<h4>Using Token Actions to Customize the Scanner</h4>

<p>
The key idea is to insert custom code into the scanner using SmaCC's <em>token actions</em>.
Recall from Section <a href="#TokenActionMethods"></a> on <em>Token Action Methods</em> that, whenever a SmaCC scanner recognizes a token, a correspondingly-named method in the scanner will be executedâif such a method exists.
Now consider the following token definitions from Grace's grammar:
</p>
<figure><pre><code>default &lt;whitespace&gt; :  ( \x20 | \xA0 ) + ;
default &lt;newline&gt; :  ( \r | \n |  \r\n  | \x2028 ) &lt;whitespace&gt; ? ;</code></pre><figcaption></figcaption></figure>

<p>
Grace distinguishes between spaces and newlines.
There is an inherited token action for <code>&lt;whitespace&gt;</code>
that resets the scanner to start looking for a new token, but ignores the whitespace itself.
This is fine for our purposes, so long as it applies only to spaces, and not to newlines.
For the latter, we need to write a separate method; the <code>newline</code> method in <code>GraceScanner</code> starts like this.
</p>
<figure><pre><code>newline
    &quot;a newline has been matched (including the spaces that follow it).
    Depending on the state of the scanner, classify it as &lt;whitespace&gt; (when 
    the following line is a continuation line) or a real &lt;newline&gt; token.&quot;

    self checkAndRecordIndentStatus.
    self isLineEmpty
        ifTrue: [ ^ self whitespace ].
    self isIndentationChangeOne
        ifTrue: [ self lexicalError: 'a change of indentation of 1 is not permitted' ].
    self terminateContinuationIfNecessary.
    self isBlockStart ifTrue: [ 
            self recordNewIndentation.
            self saveDataForPriorLine.
            ^ self priorLineEndsWithOpenBracket 
                ifTrue: [ self whitespace ]
                ifFalse: [ self createTokenFor: Character cr asString ] ].
    ... &quot;more cases, omitted for brevity&quot;</code></pre><figcaption></figcaption></figure>

<p>
Depending on the state of the scanner, this method will do one of three things.
</p>
<ol><li>Return <code>self whitespace</code> if the newline is to be ignored, that is, to be treated like a space.</li>
<li>Return a newline token; the grammar for Grace treats newlines as statement separators, so when the parser sees such a token, it recognizes the end of a statement.</li>
<li>Signal an exception, which will be caught by the surrounding context and used to produce an error message for the user.</li>
</ol>


<h4>Using Newlines to Separate Statements</h4>

<p>
To use newlines to separate statements, the grammar for Grace defines the non-terminal <code>Ssep</code> (statement separator) like this:
</p>
<figure><pre><code>Ssep
    : &quot;;&quot;
    | &lt;newline&gt;
    | Ssep 'ss' ( &quot;;&quot; | &lt;newline&gt; )
    ;</code></pre><figcaption></figcaption></figure>

<p>
Hence, a semicolon, a newline, or any series of semicolons and newlines are all treated as statement separators.
Other productions are then written using <code>Ssep</code>.
For example, here is part of the definition of a <code>Block</code>, which is a sequence of statements.
</p>
<figure><pre><code>Block
    : ...
    | &quot;{&quot; Ssep '_' ? ( Statement 'item' ( Ssep '_' Statement  'item' ) * Ssep '_' ? ) ?  &quot;}&quot;</code></pre><figcaption></figcaption></figure>

<p>
Notice that the grammar is explicit about allowing (but not requiring) a newline (or a semicolon) after the <code>{</code> that opens the block, allowing (but not requiring) a newline (or a semicolon) before the <code>}</code> that closes the block, and requiring a newline or semicolon between the <code>Statement</code>s in the block.
</p>

<h4>Augmenting the State of the Scanner</h4>

<p>
What do we mean by âthe state of the scannerâ?
That is very much up to you.
You can introduce as many extra instance variables into the scanner as you need to track whatever language features you need to implement.
</p>
<p>
In Grace, the rule is that indentation <em>must</em> increase after a <code>{</code>, and must return to the prior level with (or after) the matching <code>}</code>.
This means, of course, that we need to keep track of the number of <code>{</code> and <code>}</code> tokens on the line that has just ended, so that we know if there were more of one than the other.
To do this, we need to add a variable <code>currentLineBraceDepth</code> to <code>GraceScanner</code>.
We can do this directly by editing the class definition for <code>GraceScanner</code>; there is no SmaCC directive to add scanner instance variables
(This is unlike AST instance variables, where we must use the <code>%attributes</code> directive).
We add an <code>initialize</code> method in <code>GraceScanner</code> to set the initial value of <code>currentLineBraceDepth</code> to 0, and add token action methods <code>leftBrace</code> and <code>rightBrace</code>.
Here is the <code>leftBrace</code> method.
</p>
<figure><pre><code>leftBrace
    (state = #default) ifTrue:  [ self incrementBraceDepth ].
    ^ self createTokenFor: '{'</code></pre><figcaption></figcaption></figure>

<p>
Notice once again that, because it is a token action method, this method must return a token.
Before it does so, it increments the brace depthâbut only if the scanner is in the <code>default</code> state.
If, for example we are in the <code>uninterpString</code> state, incrementing the brace depth would not be appropriate, because a <code>{</code> in an uninterpreted string does not start a code block.
</p>
<p>
In contrast, in an <em>interpreted</em> string, <code>{</code> <em>does</em> start a code block;
Grace handles that using the SmaCC parser action for starting a string interpolation:
</p>
<figure><pre><code>StartInterp: { self state: #default. scanner incrementBraceDepth. ^ nil } ;</code></pre><figcaption></figcaption></figure>

<p>
To ensure that indentation corresponds to brace depth, we also need to know the brace depth of the prior line.
At the end of the <code>newline</code> method, we copy <code>currentLineBraceDepth</code> into another scanner variable, <code>priorLineBraceDepth</code>.
For convenience, at the start of the <code>newline</code> method, we compute the <code>braceChange</code> as the difference between <code>currentLineBraceDepth</code> and <code>priorLineBraceDepth</code>.
</p>

<h4>Unnamed Tokens</h4>

<p>
These token actions for braces would work fine if Grace's grammar defined <code>leftBrace</code> and <code>rightBrace</code> as named tokens in the scanner, and then used those names in the grammar productions.
This <em>is</em> what it does for newlines, but in fact Grace's grammar is written using literal <code>&quot;{&quot;</code> and <code>&quot;}&quot;</code> tokens.
That is, we write:
</p>
<figure><pre><code>Block
    : ...
    | &quot;{&quot; Ssep '_' ? ( Statement 'item' ( Ssep '_' Statement  'item' ) * Ssep '_' ? ) ?  &quot;}&quot;</code></pre><figcaption></figcaption></figure>

<p>
and not
</p>
<figure><pre><code>    : ...
    | &lt;leftBrace&gt; Ssep '_' ? ( Statement 'item' ( Ssep '_' Statement  'item' ) * Ssep '_' ? ) ?  &lt;rightBrace&gt;</code></pre><figcaption></figcaption></figure>

<p>
because the latter is harder to read.
</p>
<p>
SmaCC happily turns literal tokens like <code>&quot;{&quot;</code> into scanner tokens; you can see them in the <em>Symbols</em> tab at the bottom of SmaCC's GUI.
But it names these tokens with quoted strings.
This is a problem because we can't write a Smalltalk token action method with a name such as <code>&quot;{&quot;</code>.
What should we do to set up the connection between the <code>leftBrace</code> method and the <code>&quot;{&quot;</code> token?
</p>
<p>
Before we can answer that question, we need to look and see how SmaCC sets up the connection between a <em>named</em> token and its token action method.
To make this possible, SmaCC generates a method in the scanner called <code>tokenActions</code> that returns an array.
Each entry in that array corresponds to a scanner token, using the numeric codes that you see in the <em>Scanner</em> tab of SmaCC's GUI.
If the array entry is <code>nil</code>, there is no special action for the corresponding symbol; otherwise, the scanner performs the action specified.
The code that implements this is found at the end of <code>SmaCCScanner&gt;&gt;reportLastMatch</code>.
Here is a slightly simplified version:
</p>
<figure><pre><code>    action := self tokenActions at: matchActions first.
    ^ action notNil
        ifTrue: [ self perform: action ]
        ifFalse: [ self createTokenFor: string ]</code></pre><figcaption></figcaption></figure>

<p>
In this code, <code>matchActions</code> is an <em>array</em> of scanner symbols that describe the token that has just been matched.
Recall that SmaCC allows you to write overlapping symbol definitions; if you do so, this array will contain <em>all</em> those that match the input.
If there is a single match, the array will have size 1.
The array contains the numeric symbol codes used internally by the scanner; these codes are used to index into the <code>tokenActions</code> array.
</p>
<p>
Let's assume that SmaCC happens to assign the numeric code 41 to <code>&lt;whiteSpace&gt;</code>, 42 to <code>&lt;comment&gt;</code> and 43 to <code>&lt;newline&gt;</code>.
The <code>tokenActions</code> array generated by SmaCC will contain mostly <code>nil</code>, but elements 41, 42 and 43 will then be <code>#whitespace</code>, <code>#comment</code> and <code>#newline</code>, because SmaCC found methods with these names in the scanner when it generated the table.
</p>
<p>
Now that we know about the <code>tokenActions</code> array, it's a fairly simple matter to patch-in the names of the <code>leftBrace</code> and <code>rightBrace</code> token action methods at the appropriate indexes.
We do this in the <em>class side</em> initialization, so that it is done just once, not every time a scanner is run.
Here are the methods.
</p>
<figure><pre><code>initialize
    self patchTokenActions</code></pre><figcaption></figcaption></figure>

<figure><pre><code>patchTokenActions
    | tokenActionsLiteral newTokenActions |
    (GraceParser canUnderstand: #symbolNames) ifFalse: [ ^ self ]. 
        &quot;this guard is here because when this code is first loaded, the generated method symbolNames will not yet exist&quot;
    symbolNames := GraceParser new symbolNames.
    tokenActionsLiteral := self new tokenActions.                        &quot;the old literal array object&quot;
    newTokenActions := tokenActionsLiteral copy.
    self patch: '&quot;{&quot;' withAction: #leftBrace inArray: newTokenActions.
    self patch: '&quot;}&quot;' withAction: #rightBrace inArray: newTokenActions.
    self patch: '&quot;:=&quot;' withAction: #assignmentSymbol inArray: newTokenActions.
    self patchReservedWordsWithAction: #reservedWord inArray: newTokenActions.
    
    (newTokenActions = tokenActionsLiteral) ifFalse: [ 
        self installNewTokenActionsArray: newTokenActions.
    ]</code></pre><figcaption></figcaption></figure>

<figure><pre><code>patch: token withAction: action inArray: tokenActions
    | location |
    location := symbolNames indexOf: token.
    tokenActions at: location put: action</code></pre><figcaption></figcaption></figure>

<figure><pre><code>installNewTokenActionsArray: anArray
    | newMethod |
    newMethod := String streamContents: [ :s | 
        s &lt;&lt; 'tokenActions' ; cr ; tab ; &lt;&lt; '^ '; &lt;&lt; anArray printString ]. 
    self compile: newMethod classified: 'generated'</code></pre><figcaption></figcaption></figure>

<p>
Inconveniently, the list of symbol names is stored in an instance method of the parser, not in the scanner.
We add a class instance variable <code>symbolNames</code> to cache this information in the scanner.
You will notice that, in addition to patching-in actions for the left and right braces, we also patch-in actions for the assignment symbol and for reserved words.
We will not discuss these actions here, because they are not related to handling layout.
</p>
<p>
Having calculated the new token actions array, we need to get SmaCC to use it.
If SmaCC had stored it in a variable, all that would be necessary would be to overwrite that variable.
But it is stored as a literal in a method!
We handle this problem by simply generating and compiling a modified version of that method.
The ease with which Smalltalk lets us do meta-programming saves the day.
</p>
<p>
There is actually an alternative to compiling a new method, which we will encourage you <em>not</em> to use!
Because of what many people regard as a bug in the Smalltalk language specification, it is actually possible to modify an array literal.
That is, rather than copying the literal as we have done, it is possible to perform <code>at:put:</code> operations on the literal itself!
There are several problems with doing this, not the least of which is that when you read the code, you will see one thing, but when you execute it, you will get another.
In our view, recompiling the method that returns the literal is a far better approach.
</p>
<p>
Perhaps in a future version of SmaCC, there will be a directive to connect un-named tokens with token actions.
Then, the work-around we have just described will not be necessary.
Nevertheless, it does well-illustrate the amazing flexibility of SmaCC.
</p>

<h4>Closing Blocks</h4>

<p>
With brace depth being tracked by the <code>leftBrace</code> and <code>rightBrace</code> methods, the <code>newline</code> method has the information that it needs to check that the indentation increases after each left brace.
We also need to check that indentation returns to the previous level with the matching right brace.
This requires that we keep a stack of prior indentations, push the new indentation onto the stack then we see an increase, pop it when we see a decrease, and check that the new, decreased indentation is the same as the value on the top of the stack.
This requires another scanner instance variable, which we call <code>indentStack</code>.
</p>
<p>
There is a slight complication because Grace allows both of the following forms
</p>
<figure><pre><code>if (condition) then {
    blockBody1
    blockBody2 }
nextStatement</code></pre><figcaption></figcaption></figure>

<p>
and
</p>
<figure><pre><code>if (condition) then {
    blockBody1
    blockBody2
}
nextStatement</code></pre><figcaption></figcaption></figure>

<p>
that is, a right brace can appear either at the <em>end</em> of the last line of a block, in which case the line containing the brace is indented, <em>or</em> at the <em>start</em> of the line that follows the block.
In the latter case the right brace is <em>not</em> indented, but must be at the same indentation as the line that contains the corresponding left brace.
The second case looks better, but is actually anomalous: when the line containing just the right brace starts, 
the block has not yet been closed, so we would normally expect the line to be indented.
It's fairly easy to make an exception for this case:
</p>
<figure><pre><code>checkAndRecordIndentStatus
    currentCharacter = Character tab ifTrue: [ ^ self lexicalError: 'Please indent with spaces, not tabs' ].
    braceChange := currentLineBraceDepth - priorLineBraceDepth.
    currentCharacter = $} ifTrue: [ braceChange := braceChange - 1 ].
    currentLineIndent := self calculateCurrentIndent</code></pre><figcaption></figcaption></figure>

<p>
The scanner variable <code>currentCharacter</code> is set by SmaCC to contain the character <em>following</em> those that make up the token that has just been matchedâin our case, the character following the newline and the leading spaces.
So it is easy to check if it is a right brace, and adjust <code>braceChange</code> if necessary.
</p>
<p>
The scanner variable <code>outputStream</code> is a stream that contains all of the characters that SmaCC has determined make up the current token.
In the case of a newline token, this will be the line end sequence itself, and the spaces that follow it.
We use this variable to calculate the current indent:
</p>
<figure><pre><code>calculateCurrentIndent
    | ch str |
    str := ReadStream on: outputStream contents.
    ch := str next.
    self assert: [ (ch = Character lf) or: [ch = Character cr or: [ch = (Character codePoint: 16r2028)] ] ].
    (ch = Character cr) ifTrue: [str peekFor: Character lf].
    ^ str size - str position</code></pre><figcaption></figcaption></figure>

<p>
The Grace language specification says that a line feed following a carriage return is ignored, so we are careful not to include it when we calculate the indentation.
It should also be possible to use the character position reported by <code>SmaCCLineNumberStream</code> to calculate the current indent.
</p>

<h4>Continuation Lines</h4>

<p>
If Grace changed indentation <em>only</em> to indicate an increase in the brace level, the <code>newline</code> token action method would be quite simple, and we would already have the all the pieces we need.
However, Grace also uses indentation to indicate a continuation line, that is, two or more physical lines that should be treated as a single logical line.
This is useful when a single statement is too long to fit on a line, and it is necessary to break it into several lines; the additional line breaks should <em>not</em> be treated as spaces.
Python signals continuation lines by requiring that the programmer escape the intermediate newline by preceeding it with a backslash; this is simpler for the scanner, but uglier for the reader.
</p>
<p>
Grace's rule is that an increase in indentation that does <em>not</em> correspond to the start of a code block signals a continuation line.
Further lines with the same (or greater) indentation are part of the continuation; the end of the continuation is signalled by a return 
to the previous indentation, or by an un-matched left brace.
</p>
<p>
Dealing with continuations requires another state variable <code>indentOfLineBeingContinued</code>, which is <code>nil</code> if no line is being continued.
Another variable, <code>maxIndentOfContinuation</code>, tracks the maximum indentation of the continuation.
</p>

<h4>Ignoring Blank Lines</h4>

<p>
Another of Grace's indentation rules says that blank lines are ignored for indentation purposes.
If this were not so, the number of spaces on a line that appears blank would be significantâa problem since these trailing spaces are invisible, and are often removed by text editors.
Lines that contain nothing but a comment are treated as blank for the same reason; it seems excessive to require that the <code>//</code> symbol that introduces the comment to be at a specific indentation.
</p>
<p>
Implementing the first part of this rule is simple, but the part that treats comment lines as blank requires look-ahead.
Here is how we implement the <code>isLineEmpty</code> check.
</p>
<figure><pre><code>isLineEmpty
    &quot;answers true if the line that we just started is empty.
    A line containing nothing but a comment is treated as empty,
    so that comments do not reset the indentation.&quot;
    
    (newlineChars includes: currentCharacter) ifTrue: [ ^ true ].
    ($/ ~= currentCharacter) ifTrue: [ ^ false ].
    ^ stream explore: [ :s | 
        s next.
        ($/ = s next)
    ]</code></pre><figcaption></figcaption></figure>

<p>
The first line returns early with <code>true</code> if there is nothing on the line but spaces; remember that any leading spaces will have been included as part of the <code>&lt;newline&gt;</code> token.
The second line returns early with <code>false</code> if the first non-space character is not <code>/</code>, because in those cases we know that the line does not start with a comment.
The remaining case is where the first non-space character <em>is</em> <code>/</code>; we need to see if it is followed by a second <code>/</code>, indicating a comment, or by some other character, in which case the initial <code>/</code> was an operator symbol.
To do this we use <code>explore:</code> on <code>stream</code>, the scanner instance variable that names the inout stream.
<code>explore: withABlock</code> saves the position of the stream, evaluate the code <code>withABlock</code>, and then resets the stream to the saved position.
The method <code>explore:</code> is implemented in the wrapper class <code>SmaCCLineNumberStream</code>, but it is only as good as the <code>position:</code> method in the underlying stream.
Currently, there are some issues with <code>position:</code> on streams that contain multiple-byte characters; the workaround is to read the whole stream into a string, and then create a stream on the string.
</p>

<h4>The Rest of the Story</h4>

<p>
If you wish to see all the details, the code for the Grace parser is available on <a href="https://github.com/apblack/GraceInPharo.git">github</a>.
</p>

<h2>SmaCC Transformations</h2>


<p>
Once you have generated a parser for your language, you can use SmaCC to transform programs written in your language.
Note that the output from the transformation phase is the text of a program (which may be in the input language or another language) and not a parse tree.
</p>

<h3>Defining Transformations </h3>

<p>
Let's add support for transforming the simple expression language of our calculator example.
The basic idea is to define <em>patterns</em> that match subtrees of the grammar, and specify how these subtrees should be rewritten.
</p>
<p>
We start by extending our grammar with two additional lines.
</p>
<p>
The first line defines how we will write a pattern in our grammar.
SmaCC has a small built-in pattern syntax: it is in fact the language of your grammar plus metavariables.
Metavariables will hold the matching subtree after the pattern matching part of the transformation.
To identify a metavariable, your scanner should define the <code>&lt;patternToken&gt;</code>: SmaCC uses this token to define metavariables.
For our example language, we will define a metavariable as anything enclosed by <code>`</code> characters (e.g., <code>`pattern`</code>).
Note that this token, despite its special behaviour, is still valid in the scanner and thus should not conflict with other token definitions.
</p>
<p>
The second line we need to add tells SmaCC to generate a GLR parser (<code>%glr;</code>).
This allows SmaCC to parse <em>all possible</em> representations of a pattern expression, rather than just one.
</p>
<p>
Here is our grammar with these two additions.
</p>
<figure><pre><code>	&lt;number&gt; : [0-9]+ (\. [0-9]*) ? ;
	&lt;name&gt; : [a-zA-Z]\w*;
	&lt;whitespace&gt; : \s+;

+	&lt;patternToken&gt; : \` [^\`]* \` ;
+	%glr;

	%left &quot;+&quot; &quot;-&quot;;
	%left &quot;*&quot; &quot;/&quot;;
	%right &quot;^&quot;;

	%annotate_tokens;
	%root Expression;
	%prefix AST;
	%suffix Node;
	%ignore_variables leftParenToken rightParenToken;

	Expression 
		: Expression 'left' &quot;+&quot; 'operator' Expression 'right' {{Binary}}
		| Expression 'left' &quot;-&quot; 'operator' Expression 'right' {{Binary}}
		| Expression 'left' &quot;*&quot; 'operator' Expression 'right' {{Binary}}
		| Expression 'left' &quot;/&quot; 'operator' Expression 'right' {{Binary}}
		| Expression 'left' &quot;^&quot; 'operator' Expression 'right' {{Binary}}
		| &quot;(&quot; Expression &quot;)&quot; {{}}
		| Number
		| Function
        ;

	Number
        : &lt;number&gt; {{Number}}
        ;

	Function
		: &lt;name&gt; &quot;(&quot; 'leftParen' (Expression 'argument' (&quot;,&quot; Expression 'argument')* )? &quot;)&quot; 'rightParen' {{}}
        ;</code></pre><figcaption></figcaption></figure>

<p>
And that is the only two things you need to do to activate the Rewrite Engine for your new language.
</p>

<h3>Pattern matching Expressions</h3>

<p>
Having made these changes, we can now define <em>rewrite rules</em> that specify how certain subtrees in the AST should be matched (the pattern) and how their substrings should be replaced (the transformation). 
Patterns look like normal code from your language, but may include metavariables that are delimited by the <code>&lt;patternToken&gt;</code>. 
</p>
<p>
For example, <code>`a` + 1</code> is a pattern that matches any expression followed by <code>+ 1</code>. 
The metavariable is <code>a</code>; when the pattern matches, <code>a</code> will be bound to the AST node of the expression that is followed by <code>+1</code>.
</p>
<p>
To rewrite the matches of the pattern in our program, we must supply a transformation, which can contain the metavariables present in the pattern.
A crucial distinction is that the metavariables are now instantiated with their corresponding to their matched subtree.
After the transformation, a new string is returned with the program appropriately rewritten where the pattern was matched.  
</p>
<p>
For example, if we are searching for the pattern <code>`a` + 1</code>, we can supply a replacement expression like <code>1 + `a`</code>.
This pattern will match <code>(3 + 4) + 1</code>.
When we perform the replacement we take the literal <code>1 + </code> part of the string and append the source that was parsed into the subtree that matched <code>`a`</code>.
In this case, this is <code>(3 + 4)</code>, so the replacement text will be <code>1 + (3 + 4)</code>.
</p>

<h3>Example</h3>

<p>
As an example, let's rewrite additions into reverse Polish notation.
Our search pattern is <code>`a` + `b`</code> and our replacement expression is <code>`a` `b` +</code>.
</p>
<figure><pre><code>	| rewriter compositeRewrite rewrite matcher transformation |
	compositeRewrite := SmaCCRewriteFile new.
	compositeRewrite parserClass: CalculatorParser.
	matcher := SmaCCRewriteTreeMatch new.
	matcher source: '`a` + `b`'.
	transformation := SmaCCRewriteStringTransformation new.
	transformation string: '`a` `b` +'.
	rewrite := SmaCCRewrite 
		comment: 'Postfix rewriter' 
		match: matcher
		transformation: transformation.
	compositeRewrite addTransformation: rewrite.
	rewriter := SmaCCRewriteEngine new.
	rewriter rewriteRule: compositeRewrite.
	rewriter rewriteTree: (CalculatorParser parse: '(3 + 4) + (4 + 3)')</code></pre><figcaption></figcaption></figure>

<p>
This code rewrites <code>(3 + 4) + (4 + 3)</code> in RPN format and returns <code>3 4 + 4 3 + +</code>.
The first match that this finds is <code>`a`</code> = <code>(3 + 4)</code> and <code>`b`</code> = <code>(4 + 3)</code>.
Inside our replacement expression, we refer to <code>`a`</code> and <code>`b`</code>, so we first process those expression for more transformations.
Since both contain other additions, we rewrite both expressions to get <code>`a`</code> = <code>3 4 +</code> and <code>`b`</code> = <code>4 3 +</code>.
</p>
<p>
Here's the same example, using SmaCC's special, albeit small rewrite syntax.
</p>
<figure><pre><code>	| rewriter rewriteExpression |
	rewriteExpression := 
		'Parser: CalculatorParser
		&gt;&gt;&gt;`a` + `b`&lt;&lt;&lt;
		-&gt;
		&gt;&gt;&gt;`a` `b` +&lt;&lt;&lt;'.
	rewriter := SmaCCRewriteEngine new.
	rewriter rewriteRule: (SmaCCRewriteRuleFileParser parse: rewriteExpression).
	rewriter rewriteTree: (CalculatorParser parse: '(3 + 4) + (4 + 3)')</code></pre><figcaption></figcaption></figure>

<p>
Note that when you use the same name for multiple metavariables in a pattern, all of these must be equals.
As an example <code>`i` + `i`</code> will only match addition for which the two operands are the same nodes.
</p>

<h3>Parametrizing Transformations</h3>

<p>
Let's extend our RPN rewriter to support other expressions besides addition.
We could do that by providing rewrites for all possible operators (+, -, *, /, ^), but it would be better if we could do it with a pattern.
You might think that we could use <code>`a` `op` `b`</code>, but patterns like <code>`op`</code> will match only expressions corresponding to grammar non-terminals, and not tokens like <code>(+)</code>.
We can tell SmaCC to allow <code>`op`</code> to  match tokens by using <code>`a` `op{beToken}` `b`</code>. Here's the rewrite that works for all arithmetic expressions of the calculator language.
</p>
<figure><pre><code>	Parser: CalculatorParser
	&gt;&gt;&gt;`a` `op{beToken}` `b`&lt;&lt;&lt;
	-&gt;
	&gt;&gt;&gt;`a` `b` `op`&lt;&lt;&lt;</code></pre><figcaption></figcaption></figure>

<p>
If we transform <code>(3 + 4) * (5 - 2) ^ 3</code>, we'll get <code>3 4 + 5 2 - 3 ^ *</code>.
Notice that SmaCC has performed three transformations using the same pattern-matching rule.
</p>

<h3>Restrictions and Limitations</h3>

<p>
At present, SmaCC's rewriting facility can generate only text, not parse trees.
In other words, although you can and should think of SmaCC's rewrites as matching a parse tree,
they cannot produce a modified parse tree, only modified source code.
However, if you want to write node rewrites in Smalltalk, <code>SmaCCParseNode</code> has some useful primitives to replace or add nodes to the tree.
</p>

<h2>Grammar Idioms</h2>
<a id="cha:idioms"></a>
<p>
In this chapter, we share some coding idioms for grammars that help create more
compact ASTs.
</p>
<h3>Managing Lists</h3>

<p>
Smacc automatically determines if the production rules contain a recursion that represents a list.
In such case, it adds an <code>s</code> to the name of the generated instance variable and manages it as a list.
</p>
<p>
Let us take an example.
</p>
<figure><pre><code>&lt;a&gt; : a;
&lt;whitespace&gt; : \s+;

%root Line;
%prefix SmaccTutorial;

Line 
	: &lt;a&gt; 'line' {{}}
	| Line &lt;a&gt; 'line' {{}}
	;</code></pre><figcaption></figcaption></figure>

<p>
Here we see that Line is recursive. Smacc will generate a class <code>SmaccTutorialLine</code> with an instance variable <code>lines</code> initialized as an ordered collection.
</p>
<p>
Note that, if the right-hand-side of a rule is completely empty, SmaCC does not recognise the list.
</p>
<figure><pre><code>Line 
	:
	| Line &lt;a&gt; 'line' {{}}
	;</code></pre><figcaption></figcaption></figure>

<p>
To avoid the empty right-hand-side, you should write this as follows:
</p>
<figure><pre><code>Line
	: {{}}
	| Line &lt;a&gt; 'line' {{}}
	;</code></pre><figcaption></figcaption></figure>


<h3>Using Shortcuts</h3>

<p>
You may prefer to define your lists using the shortcuts question mark (<code>?</code>) for 0 or 1 occurrences, 
star (<code>*</code>) for 0 or more, and plus (<code>+</code>) for 1 or more, rather than with recursion.
Let's compare the two approaches.
</p>
<p>
Let's look at a grammar that defines a parameter list recursively.
</p>
<figure><pre><code>&lt;name&gt; :  [a-zA-Z] [a-zA-Z0-9_']*;
&lt;whitespace&gt;:  (\x20|\xA0|\r)* ;

%root Root;
%prefix SmaccTutorial;
%annotate_tokens;

ParameterList
    : Parameter 'param' {{}}
    | ParameterList 'param' Parameter 'param' {{}}
    ;

Parameter
    : &lt;name&gt; {{}}
    ;</code></pre><figcaption></figcaption></figure>

<p>
If the above grammar is used to parse a list of three names, it will generate an AST node class 
called <code>SmaccTutorialParameterList</code> with a <code>params</code> instance variable that holds an ordered collection.
However, the contents of the ordered collection will <em>not</em> be the three parameters.
Instead, the collection will have <em>two</em> elements: a parameter list (which will contain an ordered collection of two parameters), 
and a parameter that contains the third.
Why? Because that's what the grammar specifies!
</p>
<p>
There is a trick that will instead generate a collection of three elements: remove the name <code>'param'</code> from after the 
recursive appearace of the non-terminal <code>ParameterList</code> in the second alternative for <code>ParameterList</code>:
</p>
<figure><pre><code>ParameterList
    : Parameter 'param' {{}}
    | ParameterList Parameter 'param' {{}}
    ;</code></pre><figcaption></figcaption></figure>

<p>
Now you will get a collection <code>params</code> containing <em>all</em> the parameters.
</p>
<p>
You can also specify the same language using <code>+</code>, like this:
</p>
<figure><pre><code>&lt;name&gt; :  [a-zA-Z]  ([a-zA-Z]  | [0-9] | _ | ')*;
&lt;whitespace&gt;:  (\x20|\xA0|\r)* ;

%root Root;
%prefix SmaccTutorial;
%annotate_tokens;

ParameterList
    : Parameter 'params' + {{}}
    ;

Parameter
    : &lt;name&gt; {{}}
    ;</code></pre><figcaption></figcaption></figure>

<p>
Not only is this grammar easier to read, but the generated AST will contain a single collection of parameters.
If you parse three names, the result will be a <code>SmaccTutorialParameterList</code> object that contains an instance variable <code>params</code> that will be initialized to be an <code>OrderedCollection</code> of three <code>SmaCCTutorialParameter</code> nodes.
</p>
<p>
In a similar way, if you use a <code>*</code>, you will get an ordered collection containing zero or more items.
However, if you use a <code>?</code>, you don't get a collection: you get either <code>nil</code> (if the item was absent), or the generated node (if it was present).
</p>

<h3>Expressing Optional Features</h3>

<p>
Often, lists contain separators, which makes specifying them a little more complex.
Here is a grammar in which lists of names can be of arbitrary length, but the list items must be separated with commas.
It expresses this with the <code>?</code> shortcut.
</p>
<figure><pre><code>&lt;name&gt; :  [a-zA-Z]  ([a-zA-Z]  | [0-9] | _ | ')*;
&lt;whitespace&gt;:  (\x20|\xA0|\r)* ;

%root Root;
%prefix SmaccTutorial;
%annotate_tokens;

NameList
	: ( Name 'n' ( &quot;,&quot;  Name 'n' ) *)? {{}}
	;

Name
	: &lt;name&gt;
	;</code></pre><figcaption></figcaption></figure>

<p>
SmaCC recognizes this idiom, and will generate an ordered collection of zero or more names.
If you want this behaviour, it is important to use the same instance variable name (here <code>n</code>) for both the base case and the <code>*</code> repetition.
If you use different names,
</p>
<figure><pre><code>NameList
	: ( Name 'n1' ( &quot;,&quot;  Name 'n2' ) *)? {{}}
	;</code></pre><figcaption></figcaption></figure>

<p>
then the generated node will have two instance variables:  <code>n1</code> will be either <code>nil</code> (if the input list is empty) or will contain the first <code>Name</code> (if it is not), while <code>n2s</code> will be a collection containing the remaining Names (zero when the input list has length one).
</p>

<p>
If you prefer not to use the <code>*</code> and <code>?</code> shortcuts (or are using a verison of SmaCC that does not support them), you can get the same effect using recursion:
</p>
<figure><pre><code>NameList
	:    {{}}
	|  NonEmptyNameList 
	;
	
NonEmptyNameList	
	: Name 'name' {{}}
	| NonEmptyNameList  &quot;,&quot; Name 'name' {{}} 
	;

Name
	: &lt;name&gt; {{ }}
	;</code></pre><figcaption></figcaption></figure>

<p>
Once again, note that no name is given to the recursive use of <code>NonEmptyNameList</code>.
</p>
<p>
In general, empty alternatives will be represented as <code>nil</code>.
This avoids generating many useless objects.
</p>
<figure><pre><code>NameList
	:  
	|  NonEmptyNameList 
	;</code></pre><figcaption></figcaption></figure>

<p>
<code>NameList</code> will return nil when it matches the empty input.
If instead you want an empty <code>NameList</code> node, use <code>{{}}</code> for the empty alternative:
</p>
<figure><pre><code>NameList
	:    {{}}
	|  NonEmptyNameList 
	;</code></pre><figcaption></figcaption></figure>

<h2>Conclusion</h2>

<p>
SmaCC is a really strong and stable library that is used in production for many years.
It is an essential asset for dealing with languages.
While PetitParser (See Deep into Pharo <a href="http://books.pharo.org">http://books.pharo.org</a>) is useful for composing and reusing fragments of parsers, Smacc offers speed and more traditional parsing technology.
</p>

<h2>Vocabulary</h2>

<p>
This chapter defines some vocabulary used by Smacc. 
</p>

<h3>Reference Example </h3>

<p>
Let us take the following grammar. 
</p>
<figure><pre><code>&lt;number&gt; : [0-9]+ (\. [0-9]*) ? ;
&lt;whitespace&gt; : \s+;

%left &quot;+&quot; &quot;-&quot;;
%left &quot;*&quot; &quot;/&quot;;
%right &quot;^&quot;;
%annotate_tokens;
%root Expression;
%prefix AST;
%suffix Node;

Expression 
	: Expression 'left' &quot;+&quot; 'operator' Expression 'right' {{Binary}}
	| Expression 'left' &quot;-&quot; 'operator' Expression 'right' {{Binary}}
	| Expression 'left' &quot;*&quot; 'operator' Expression 'right' {{Binary}}
	| Expression 'left' &quot;/&quot; 'operator' Expression 'right' {{Binary}}
	| Expression 'left' &quot;^&quot; 'operator' Expression 'right' {{Binary}}
	| &quot;(&quot; Expression &quot;)&quot; {{}}
	| Number
	;
Number 
	: &lt;number&gt; {{Number}}
	;</code></pre><figcaption></figcaption></figure>


<h3>Metagrammar structure</h3>

<p>
SmaCC grammars are written in EBNF format (Extended Backus-Naur Form) with a syntax ressembling closely to the one of GNU Bison.
A grammar is composed of:
</p>
<ul>
<li>Scanner rules: they define tokens to recognize in the input stream through regex,</li>
<li>Parser rules: they define the production rules of your grammar,</li>
<li>Directives: they are additionnal information for the parsing or for the AST generation.</li>
</ul>

<p>
Note that you can also find the metagrammar of SmaCC described in itself in the <code>SmaCCDefinitionParser</code>.
</p>

<h3>Elements </h3>


<h4>Production rule</h4>

<p>
The following expressions define two production rules. 
</p>
<figure><pre><code>Expression 
	: Expression 'left' &quot;+&quot; 'operator' Expression 'right' {{Binary}}
	| Expression 'left' &quot;-&quot; 'operator' Expression 'right' {{Binary}}
	;

Number 
	: &lt;number&gt; {{Number}}
	;</code></pre><figcaption></figcaption></figure>

<p>
A production rule is defined by a left hand side and several alternatives.
</p><ul>
<li>Here the first production rule has two alternatives.</li>
<li>While the seconde production rule has only one. </li>
</ul>

<p>
An alternative can be composed of any variation of:
</p><ul>
<li>non terminals often starting with uppercase</li>
<li>scanner tokens</li>
<li>keywords (delimited by <code>&quot;</code>)</li>
</ul>

<p>
In addition, you can use the single curly braces <code>{}</code> to define an arbitrary semantic  action or the double curly braces <code>{{}}</code> to create an AST node instead.
Non terminals and tokens can be annotated with variable names (delimited by <code>'</code>) that will be the instance variable names of the AST node.
</p>

<h4>Tokens</h4>

<p>
Tokens are identified by the scanner. 
A token specification is composed of a token name and a token regular expression.
</p>
<figure><pre><code>&lt;TokenName&gt;    :    RegularExpression ;</code></pre><figcaption></figcaption></figure>

<p>
The following token specification describes a number.
It starts with one or more digits, possibly followed by a decimal point with zero or more digits after it. 
The scanner definition for this token is:
</p>
<figure><pre><code>&lt;number&gt;        :       [0-9]+ (\. [0-9]*) ? ;</code></pre><figcaption></figcaption></figure>

<p>
Let's go over each part:
</p>
<dl><dt><code>&lt;number&gt;</code></dt>
<dd>Names the token identified by the expression. The name inside the &lt;&gt; must be a legal Pharo variable name.</dd>
<dt><code>:</code></dt>
<dd>Separates the name of the token from the token's definition.</dd>
<dt><code>[0-9]</code></dt>
<dd>Matches any single character in the range <code>'0'</code> to <code>'9'</code> (a digit). We could also use <code>\d</code> or <code>&lt;isDigit&gt;</code> as these also match digits.</dd>
<dt><code>+</code></dt>
<dd>Matches the previous expression one or more times. In this case, we are matching one or more digits.</dd>
<dt><code>( ... )</code></dt>
<dd>Groups subexpressions. In this case we are grouping the decimal point and the numbers following the decimal point.</dd>
<dt><code>\.</code></dt>
<dd>Matches the '.' character (. has a special meaning in regular expressions,  quotes it).</dd>
<dt><code>*</code></dt>
<dd>Matches the previous expression zero or more times.</dd>
<dt><code>?</code></dt>
<dd>Matches the previous expression zero or one time (i.e., it is optional).</dd>
<dt><code>;</code></dt>
<dd>Terminates a token specification.</dd>
</dl>


<h4>Keywords</h4>

<p>
Keywords are defined in the production and delimited by <code>&quot;</code>. 
Keywords are only defined through static strings, regular expressions cannot be used.
In the following example, <code>&quot;+&quot;</code> and <code>&quot;-&quot;</code> are considered keywords.
</p>
<figure><pre><code>Expression 
	: Expression 'left' &quot;+&quot; 'operator' Expression 'right' {{Binary}}
	| Expression 'left' &quot;-&quot; 'operator' Expression 'right' {{Binary}}
	;</code></pre><figcaption></figcaption></figure>


<h4>Non Terminal</h4>

<p>
In the production rule <code>Expression 'left' &quot;+&quot; 'operator' Expression 'right'</code>, Expression is a non terminal.
</p>

<h4>Variables</h4>

<p>
Variables give name to one element of a production.
For example 
</p>
<figure><pre><code>Expression 'left' &quot;^&quot; 'operator' Expression 'right'</code></pre><figcaption></figcaption></figure>

<ul>
<li>'left' and 'right' denote the first and second expression of the alternative.</li>
<li>'operator' denotes the caret token. </li>
</ul>



  </section>

</article>

<footer>

<div class="footline">
    <div class="github-link">
      <a href="" target="blank"><i class="fa fa-code-fork"></i>Github</a>
    </div>
  </div>
</footer>

<script src="/booklet-Smacc/html/_support/html/js/clipboard.min.js"></script>

<link href="/booklet-Smacc/html/_support/html/css/featherlight.min.css" rel="stylesheet">
<script src="/booklet-Smacc/html/_support/html/js/featherlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script src="/booklet-Smacc/html/_support/html/js/flex.js"></script>
<!-- Prettify annotated paragraphs-->
    <script src="/booklet-Smacc/html_support/html/js/annotated-paragraphs.js"></script>

  </body>
</html>
