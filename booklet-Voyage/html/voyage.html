<!DOCTYPE html>
<html>
  <head>
    <title></title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="shortcut icon" href="images/favicon.png" type="image/x-icon" />
<link href="/booklet-Voyage/html/_support/html/css/font-awesome.min.css" rel="stylesheet">
<link href="/booklet-Voyage/html/_support/html/css/nucleus.css" rel="stylesheet">
<link href="/booklet-Voyage/html/_support/html/css/flex.css" rel="stylesheet">
<link rel="stylesheet" href="/booklet-Voyage/html/_support/html/highlightjs/styles/default.css">
<link rel="stylesheet" href="/booklet-Voyage/html/_support/html/css/highlight-commands.css">
<link rel="stylesheet" href="/booklet-Voyage/html/_support/html/css/bootstrap.min.css">
<script src="/booklet-Voyage/html/_support/html/js/jquery-2.x.min.js"></script>
<script src="/booklet-Voyage/html/_support/html/highlightjs/highlight.pack.js"></script>
<script src="/booklet-Voyage/html/_support/html/js/highlight-commands.js"></script>
<meta name="description" content="">
<meta name="author" content="Esteban Lorenzano, Stéphane Ducasse, Johan Fabry and Norbert Hartl">
  </head>
  <body>
    <header>
  <div class="logo">
    <a class="baselink" href="/booklet-Voyage/html"></a>
  </div>
  <div class="burger"><a href="javascript:void(0);" style="font-size:15px;">&#9776;</a></div>
  
</header>
<article>
  <aside>
    <ul class="menu">
   		<li data-nav-id="123" class="dd-item">
    		<a href="/booklet-Voyage/html">
		       <i class="fa fa-fw fa-home"></i>
	    	</a>
        </li>

		
		  <li class="dd-item  haschildren ">
			<div>
			  <a href="/booklet-Voyage/html/Chapters/Voyage/VoyageIntro.html#voyage">
					Voyage
			  </a>
			   <i class="fa fa-angle-right fa-lg category-icon"></i> 
			</div>
			  <ul class="dd-item">
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Voyage/html/Chapters/Voyage/VoyageIntro.html#what is voyage?">
							What is Voyage?
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Voyage/html/Chapters/Voyage/VoyageIntro.html#voyage vision ">
							Voyage vision 
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Voyage/html/Chapters/Voyage/VoyageIntro.html#contents ">
							Contents 
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Voyage/html/Chapters/Voyage/VoyageIntro.html#load voyage">
							Load Voyage
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item  haschildren ">
					<div>
						<a href="/booklet-Voyage/html/Chapters/Voyage/VoyageIntro.html#install your document databases">
							Install your document databases
						</a>
						<i class="fa fa-angle-right fa-lg category-icon"></i>
					</div>

					<ul class="dd-item">
							
						<li class="dd-item">
							<a href="/booklet-Voyage/html/Chapters/Voyage/VoyageIntro.html#mongodb">MongoDB</a>
						</li>
					
					</ul>						
				</li>
				
			  </ul>
		  
		  </li>
		
		  <li class="dd-item  haschildren ">
			<div>
			  <a href="/booklet-Voyage/html/Chapters/VoyageTutorial/VoyageTutorial.html#a simple tutorial with super heroes">
					A Simple Tutorial with Super Heroes
			  </a>
			   <i class="fa fa-angle-right fa-lg category-icon"></i> 
			</div>
			  <ul class="dd-item">
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Voyage/html/Chapters/VoyageTutorial/VoyageTutorial.html#creating a connection">
							Creating a connection
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Voyage/html/Chapters/VoyageTutorial/VoyageTutorial.html#superheroes">
							SuperHeroes
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Voyage/html/Chapters/VoyageTutorial/VoyageTutorial.html#heroes ">
							Heroes 
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Voyage/html/Chapters/VoyageTutorial/VoyageTutorial.html#... and powers">
							... and Powers
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Voyage/html/Chapters/VoyageTutorial/VoyageTutorial.html#root classes">
							Root classes
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Voyage/html/Chapters/VoyageTutorial/VoyageTutorial.html#checking in mongodb">
							Checking in MongoDB
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Voyage/html/Chapters/VoyageTutorial/VoyageTutorial.html#queries">
							Queries
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item  haschildren ">
					<div>
						<a href="/booklet-Voyage/html/Chapters/VoyageTutorial/VoyageTutorial.html#other basic operations">
							Other Basic Operations
						</a>
						<i class="fa fa-angle-right fa-lg category-icon"></i>
					</div>

					<ul class="dd-item">
							
						<li class="dd-item">
							<a href="/booklet-Voyage/html/Chapters/VoyageTutorial/VoyageTutorial.html#counting">Counting</a>
						</li>
							
						<li class="dd-item">
							<a href="/booklet-Voyage/html/Chapters/VoyageTutorial/VoyageTutorial.html#removing">Removing</a>
						</li>
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item  haschildren ">
					<div>
						<a href="/booklet-Voyage/html/Chapters/VoyageTutorial/VoyageTutorial.html#adding a new root">
							Adding a new root
						</a>
						<i class="fa fa-angle-right fa-lg category-icon"></i>
					</div>

					<ul class="dd-item">
							
						<li class="dd-item">
							<a href="/booklet-Voyage/html/Chapters/VoyageTutorial/VoyageTutorial.html#when to add a new root">When to add a new root</a>
						</li>
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Voyage/html/Chapters/VoyageTutorial/VoyageTutorial.html#power as a root">
							Power as a root
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Voyage/html/Chapters/VoyageTutorial/VoyageTutorial.html#about relations">
							About relations
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Voyage/html/Chapters/VoyageTutorial/VoyageTutorial.html#extending the hero class">
							Extending the Hero class
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Voyage/html/Chapters/VoyageTutorial/VoyageTutorial.html#equipment can also have powers">
							Equipment can also have powers
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Voyage/html/Chapters/VoyageTutorial/VoyageTutorial.html#conclusion">
							Conclusion
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
			  </ul>
		  
		  </li>
		
		  <li class="dd-item  haschildren ">
			<div>
			  <a href="/booklet-Voyage/html/Chapters/Voyage/Voyage.html#persisting objects with voyage">
					Persisting Objects with Voyage
			  </a>
			   <i class="fa fa-angle-right fa-lg category-icon"></i> 
			</div>
			  <ul class="dd-item">
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Voyage/html/Chapters/Voyage/Voyage.html#create a repository">
							Create a repository
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Voyage/html/Chapters/Voyage/Voyage.html#singleton mode and instance mode">
							Singleton mode and instance mode
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Voyage/html/Chapters/Voyage/Voyage.html#voyage api">
							Voyage API
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Voyage/html/Chapters/Voyage/Voyage.html#resetting or dropping the database connection">
							Resetting or dropping the database connection
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Voyage/html/Chapters/Voyage/Voyage.html#testing and singleton">
							Testing and Singleton
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Voyage/html/Chapters/Voyage/Voyage.html#storing objects">
							Storing objects
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Voyage/html/Chapters/Voyage/Voyage.html#basic storage">
							Basic storage
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Voyage/html/Chapters/Voyage/Voyage.html#embedding objects">
							Embedding objects
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Voyage/html/Chapters/Voyage/Voyage.html#referencing other roots">
							Referencing other roots
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Voyage/html/Chapters/Voyage/Voyage.html#breaking cycles in graphs">
							Breaking cycles in graphs
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Voyage/html/Chapters/Voyage/Voyage.html#storing instances of date in mongo">
							Storing instances of Date in Mongo
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item  haschildren ">
					<div>
						<a href="/booklet-Voyage/html/Chapters/Voyage/Voyage.html#enhancing storage">
							Enhancing storage
						</a>
						<i class="fa fa-angle-right fa-lg category-icon"></i>
					</div>

					<ul class="dd-item">
							
						<li class="dd-item">
							<a href="/booklet-Voyage/html/Chapters/Voyage/Voyage.html#configuring storage">Configuring storage</a>
						</li>
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Voyage/html/Chapters/Voyage/Voyage.html#custom loading and saving of attributes">
							Custom loading and saving of attributes
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Voyage/html/Chapters/Voyage/Voyage.html#a few words concerning the oid">
							A few words concerning the OID
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Voyage/html/Chapters/Voyage/Voyage.html#querying in voyage">
							Querying in Voyage
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Voyage/html/Chapters/Voyage/Voyage.html#basic object retrieval using blocks or mongoqueries">
							Basic object retrieval using blocks or mongoQueries
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Voyage/html/Chapters/Voyage/Voyage.html#quering with elements from another root document">
							Quering with elements from another root document
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Voyage/html/Chapters/Voyage/Voyage.html#using the at: message to access embedded documents">
							Using the at: message to access embedded documents
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Voyage/html/Chapters/Voyage/Voyage.html#using the where: message to perform javascript comparisons">
							Using the where: message to perform Javascript comparisons
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item  haschildren ">
					<div>
						<a href="/booklet-Voyage/html/Chapters/Voyage/Voyage.html#using json queries">
							Using JSON queries
						</a>
						<i class="fa fa-angle-right fa-lg category-icon"></i>
					</div>

					<ul class="dd-item">
							
						<li class="dd-item">
							<a href="/booklet-Voyage/html/Chapters/Voyage/Voyage.html#querying for an object by oid">Querying for an object by OID</a>
						</li>
							
						<li class="dd-item">
							<a href="/booklet-Voyage/html/Chapters/Voyage/Voyage.html#using dot notation to access embedded documents">Using dot notation to access embedded documents</a>
						</li>
							
						<li class="dd-item">
							<a href="/booklet-Voyage/html/Chapters/Voyage/Voyage.html#expressing or conditions in the query">Expressing OR conditions in the query</a>
						</li>
							
						<li class="dd-item">
							<a href="/booklet-Voyage/html/Chapters/Voyage/Voyage.html#going beyond mongoqueries features">Going beyond MongoQueries features</a>
						</li>
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Voyage/html/Chapters/Voyage/Voyage.html#executing a query">
							Executing a Query
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Voyage/html/Chapters/Voyage/Voyage.html#basic object retrieval">
							Basic Object Retrieval
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Voyage/html/Chapters/Voyage/Voyage.html#limiting object retrieval and sorting">
							Limiting Object Retrieval and Sorting
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Voyage/html/Chapters/Voyage/Voyage.html#a simple paginator example">
							A Simple Paginator Example
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Voyage/html/Chapters/Voyage/Voyage.html#creating and removing indexes">
							Creating and Removing Indexes
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Voyage/html/Chapters/Voyage/Voyage.html#creating indexes by using osprocess">
							Creating Indexes by using OSProcess
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Voyage/html/Chapters/Voyage/Voyage.html#verifying the use of an index">
							Verifying the use of an Index
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Voyage/html/Chapters/Voyage/Voyage.html#conclusion">
							Conclusion
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
			  </ul>
		  
		  </li>
		
		  <li class="dd-item  haschildren ">
			<div>
			  <a href="/booklet-Voyage/html/Chapters/VoyageExtras/VoyageExtras.html#tips and tricks">
					Tips and Tricks
			  </a>
			   <i class="fa fa-angle-right fa-lg category-icon"></i> 
			</div>
			  <ul class="dd-item">
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Voyage/html/Chapters/VoyageExtras/VoyageExtras.html#how to query for an object by id?    ">
							How to query for an object by id?    
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item  haschildren ">
					<div>
						<a href="/booklet-Voyage/html/Chapters/VoyageExtras/VoyageExtras.html#not yet supported mongo commands">
							Not yet supported mongo commands
						</a>
						<i class="fa fa-angle-right fa-lg category-icon"></i>
					</div>

					<ul class="dd-item">
							
						<li class="dd-item">
							<a href="/booklet-Voyage/html/Chapters/VoyageExtras/VoyageExtras.html#indexes">Indexes</a>
						</li>
							
						<li class="dd-item">
							<a href="/booklet-Voyage/html/Chapters/VoyageExtras/VoyageExtras.html#backup">Backup</a>
						</li>
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Voyage/html/Chapters/VoyageExtras/VoyageExtras.html#useful mongo commands">
							Useful mongo commands
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Voyage/html/Chapters/VoyageExtras/VoyageExtras.html#storing instances of date in mongo">
							Storing instances of Date in Mongo
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Voyage/html/Chapters/VoyageExtras/VoyageExtras.html#database design">
							Database design
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
		   	  	<li class="dd-item ">
					<div>
						<a href="/booklet-Voyage/html/Chapters/VoyageExtras/VoyageExtras.html#retrieving data ">
							Retrieving data 
						</a>
						
					</div>

					<ul class="dd-item">
					
					</ul>						
				</li>
				
			  </ul>
		  
		  </li>
		
    </ul>
  </aside>

  <section class="page">
    
	<h1>Voyage: Persisting Objects in Document Databases</h1>
		
	
<h2>Voyage</h2>
<a id="cha:voyageintro"></a>

<p>
Voyage is a small persistence framework developed by Esteban Lorenzano, constructed as a small layer between the objects and a persistency mechanism often a document noSql database.
 
This booklet started as a number of blog posts by Esteban Lorenzano, which have been extensively reworked by Johan Fabry and Stéphane Ducasse, including additional information shared by Sabine Manaa and Norbert Hartl. This became the chapter in the Enterprise Pharo book available at <a href="http://books.pharo.org">http://books.pharo.org</a>). Since this chapter was complex to edit without producing a complete version of the book and that extra material such as the super heroes tutorial written by Stephane Ducasse appeared the current booklet is a merge of all the sources and will be the most actively maintained documentation. 
</p>


<h3>What is Voyage?</h3>

<p>
It is purely object-oriented and has as a goal to present a minimal API to most common development usages. Voyage is a common layer for different backends but currently it supports just two: an <em>in-memory</em> layer and a backend for the MongoDB database (<a href="http://mongodb.org/">http://mongodb.org</a>) and UnqLite (<a href="https://www.unqlite.org">https://www.unqlite.org</a>).
</p>
<p>
The in-memory layer is useful to prototype applications quickly and for initial development without a database back-end, for example using the Pharo image as the persistency mechanism.
</p>

<p>
The MongoDB database backend stores the objects in a document-oriented database. In MongoDB each stored entity is a JSON-style document. This document-centric nature allows for persisting complex object models in a fairly straightforward fashion. MongoDB is not an object database, like Gemstone, Magma or Omnibase, so there still is a small gap to be bridged between objects and documents. To bridge this gap, Voyage contains a mapper converting objects to and from documents. This mapper is equivalent to an Object-Relational Mapper (ORM) when using relational databases. While this mapper does not solve all the known impedance mismatch issues when going from objects to a database, we find that using a document database fits better with the object world than a combination of a ORM and a relational database. This is because document databases tend to provide better support for the dynamic nature of the object world.
</p>
<p>
Voyage provides a default way in which objects are stored in the database. Fine-grained configuration of this can be performed using Magritte descriptions. Voyage also includes a query API, which allows specific objects to be retrieved from a MongoDB database. We will discuss each of these features in this text.
</p>


<h3>Voyage vision </h3>

<p>
Here are the design guidelines that drove Voyage development. 
</p><ul>
<li><strong>It should be simple.</strong> Voyage minimizes the descriptions to be given by the developer.</li>
<li><strong>It should ensure object identity.</strong> Voyage ensures that you cannot have inconsistencies by having one object reloaded with a different identity than the one it got. </li>
<li><strong>It should provide error-handling.</strong></li>
<li><strong>It should minimize communication.</strong> Voyage implements a connection pool. </li>
</ul>


<p>
Voyage does not define a Voyage Query Language but use the underlying back-end query language. You have to use the MongoDB query language even if you can use blocks to define queries you can also use JSON dictionaries to express queries since MongoDB internally uses JSON. 
</p>


<h3>Contents </h3>

<p>
This booklet has several chapters
</p>
<ul>
<li>One is a simple tutorial to get started with Voyage.</li>
<li>Then a more complete overview of the API is described.</li>
<li>Finally a chapter gathering tips and tricks is presented.</li>
</ul>

<h3>Load Voyage</h3>

<p>
To install Voyage, including support for the MongoDB database, go to the Configurations Browser (in the World Menu/Tools) and load ConfigurationOfVoyageMongo. Or alternatively execute in a workspace:
</p>
<figure><pre><code>Gofer it
   url: 'http://smalltalkhub.com/mc/estebanlm/Voyage/main';
   configurationOf: 'VoyageMongo';
   loadStable.</code></pre><figcaption></figcaption></figure>

<p>
This will load all that is needed to persist objects into a Mongo database.
</p>
<h3>Install your document databases</h3>

<h4>MongoDB</h4>
<p>
Next is to install the MongoDB database. How to do this depends on the operating system, and is outside of the scope of this text. We refer to the <a href="http://www.mongodb.org/downloads">MongoDB website</a> for more information.
</p>




<h2>A Simple Tutorial with Super Heroes</h2>

<p>
This chapter describes a step by step tutorial showing the possibilities offered by Voyage (an object to document mapper)
We will use a simple but not trivial domain: super heroes, super powers and their equipments.
You will learn how to save and retrieve objects. 
</p>


<h3>Creating a connection</h3>

<p>
One you installed MongoBD, we can start to connect to the database as follows:
</p>
<figure><pre><code>| repository |
repository := VOMongoRepository 
		host: 'localhost' 
		database: 'superHeroes'.
repository enableSingleton.</code></pre><figcaption></figcaption></figure>


<p>
If you are not connected to a database, you can always use <em>in memory</em>repository (useful for prototyping your application).
</p>
<figure><pre><code>| repository |
repository := VOMemoryRepository new. 
repository enableSingleton</code></pre><figcaption></figcaption></figure>

<p>
With this approach you can work as if you would be connected to a real database and later during your development you will be able to 
transparently switch mode. 
</p>
<p>
Usually we define one single method to set up the repository. 
For example, we can add a class method to the class <code>Hero</code> that we will define just after.
</p>
<figure><pre><code>Hero class &gt;&gt; setUpConnection
	| repository |
	repository := VOMongoRepository 
		host: 'localhost' 
		database: 'superHeroes'.
	repository enableSingleton.</code></pre><figcaption></figcaption></figure>


<h3>SuperHeroes</h3>

<p>
Now we can define a first version of our domain. Figure <a href="#HeroesModel"></a> shows the model that we will use for this tutorial. 
</p>
<p>
<a id="HeroesModel"></a>
<figure>
	<img src="Chapters/VoyageTutorial/figures/HeroesModel.png" width="60%" id="HeroesModel" alt="The model: SuperHeroes, SuperPowers and their Equipments."/>
	<figcaption>The model: SuperHeroes, SuperPowers and their Equipments.</figcaption>
</figure>
</p>
<h3>Heroes </h3>
<p>
Let us define the class <code>Hero</code>.
</p>
<figure><pre><code>Object subclass: #Hero
   instanceVariableNames: 'name level powers' 
   classVariableNames: ''
   package: 'SuperHeroes'</code></pre><figcaption></figcaption></figure>

<figure><pre><code>Hero &gt;&gt; name 
   ^ name
   
Hero &gt;&gt; name: aString 
   name := aString</code></pre><figcaption></figcaption></figure>

<figure><pre><code>Hero &gt;&gt; level 
   ^ level

Hero &gt;&gt; level: anObject 
   level := anObject</code></pre><figcaption></figcaption></figure>

<figure><pre><code>Hero &gt;&gt; powers
   ^ powers ifNil: [ powers := Set new ]</code></pre><figcaption></figcaption></figure>

<figure><pre><code>Hero &gt;&gt; addPower: aPower 
   self powers add: aPower</code></pre><figcaption></figcaption></figure>

<h3>... and Powers</h3>
<p>
Let us define the class <code>Power</code>.
</p><figure><pre><code>Object subclass: #Power 
   instanceVariableNames: 'name' 
   classVariableNames: '' 
   package: 'SuperHeroes'</code></pre><figcaption></figcaption></figure>

<figure><pre><code>Power &gt;&gt; name 
   ^ name
   
Power &gt;&gt; name: aString 
   name := aString</code></pre><figcaption></figcaption></figure>

<p>
Ajoutez les méthodes <code>printOn:</code> afin d'améliorer la navigation et le débuggage de vos super heroes.
</p>

<h3>Root classes</h3>

<p>
Now we have to decide what are the objects that we want to save and query. For this we should declare
the roots of the object graph that we want to save. A root can be any class of the system. Declaring a root is done by implementing the class method <code>isVoyageRoot</code> 
on the class of the objects that we want to save. We will see the implications of defining a root later. For now we just define <code>Hero</code> as root. 
</p>
<figure><pre><code>Hero class &gt;&gt; isVoyageRoot 
   ^ true</code></pre><figcaption></figcaption></figure>

<p>
We can create some superheroes and save them in the database.
</p><figure><pre><code>Hero new
   name: 'Spiderman';
   level: #epic;
   addPower: (Power new name: 'Super-strength');
   addPower: (Power new name: 'Wall-climbing');
   addPower: (Power new name: 'Spider instinct');
   save.
Hero new
   name: 'Wolverine';
   level: #epic;
   addPower: (Power new name: 'Regeneration');
   addPower: (Power new name: 'Adamantium claws');
   save.</code></pre><figcaption></figcaption></figure>


<h3>Checking in MongoDB</h3>

<p>
We can check directly in the database to see how our objects are saved. 
</p>
<figure><pre><code>&gt; show dbs
local        0.078GB
superHeroes  0.078GB

&gt; use superHeroes
switched to db superHeroes

&gt; show collections
Hero</code></pre><figcaption></figcaption></figure>

<p>
Now we can see how a superhero is actually stored.
<code>db.Hero.find()[0]</code> gets the first object of the collection. 
</p>
<figure><pre><code>&gt; db.Hero.find()[0]
{
	&quot;_id&quot; : ObjectId(&quot;d847065c56d0ad09b4000001&quot;),
	&quot;#version&quot; : 688076276,
	&quot;#instanceOf&quot; : &quot;Hero&quot;,
	&quot;level&quot; : &quot;epic&quot;,
	&quot;name&quot; : &quot;Spiderman&quot;,
	&quot;powers&quot; : [
		{
			&quot;#instanceOf&quot; : &quot;Power&quot;,
			&quot;name&quot; : &quot;Spider instinct&quot;
		},
		{
			&quot;#instanceOf&quot; : &quot;Power&quot;,
			&quot;name&quot; : &quot;Super-strength&quot;
		},
		{
			&quot;#instanceOf&quot; : &quot;Power&quot;,
			&quot;name&quot; : &quot;Wall-climbing&quot;
		}
	]
}</code></pre><figcaption></figcaption></figure>

<p>
Note the way the powers are saved: they are embedded inside the document that represents the superhero.
</p>
<h3>Queries</h3>

<p>
Now from Pharo, we can perform some queries to get objects stored in the database.
</p>
<figure><pre><code>Hero selectAll.  
&gt; an OrderedCollection(a Hero( Spiderman ) a Hero( Wolverine )</code></pre><figcaption></figcaption></figure>


<figure><pre><code>Hero selectOne: [ :each | each name = 'Spiderman' ].
&gt; a Hero( Spiderman )</code></pre><figcaption></figcaption></figure>

<figure><pre><code>Hero selectMany: [ :each | each level = #epic ]. 
&gt; an OrderedCollection(a Hero( Spiderman ) a Hero( Wolverine )</code></pre><figcaption></figcaption></figure>


<p>
Since MongoDB is storing internally JSON, the argument of a query can be 
a dictionary as follows:
</p>
<figure><pre><code>Hero selectOne: { #name -&gt; 'Spiderman' } asDictionary.
&gt; a Hero( Spiderman ) </code></pre><figcaption></figcaption></figure>

<figure><pre><code>Hero selectMany: { #level -&gt; #epic } asDictionary.
&gt; an OrderedCollection(a Hero( Spiderman ) a Hero( Wolverine )</code></pre><figcaption></figcaption></figure>

<p>
Here is a more complex query:
</p>
<figure><pre><code>Hero
	selectMany: { #level -&gt; #epic } asDictionary 
	sortBy: { #name -&gt; VOOrder ascending } asDictionary
	limit: 10
	offset: 0</code></pre><figcaption></figcaption></figure>

<h3>Other Basic Operations</h3>

<p>
Here are some simple operations that can be performed on root classes.
</p>
<h4>Counting</h4>
<p>
First we show how we can count:
</p>
<figure><pre><code>Hero count. 
&gt; 2</code></pre><figcaption></figcaption></figure>


<figure><pre><code>Hero count: [ :each | each name = 'Spiderman' ] 
&gt; 1</code></pre><figcaption></figcaption></figure>

<h4>Removing</h4>

<p>
We can remove objects from the database.
</p>
<figure><pre><code>hero := Hero selectAll anyOne. 
hero remove.
&gt; a Hero</code></pre><figcaption></figcaption></figure>

<p>
We can also remove all the objects from the class. 
</p><figure><pre><code>Hero removeAll. “Beware of this!” 
&gt; Hero class</code></pre><figcaption></figcaption></figure>

<h3>Adding a new root</h3>

<p>
Now we will change our requirement and show that we want to be able to query another class of objects: the powers. Note that when you add a root, it is important that you either flush your database or perform a migration by for example loading old objects are republishing them. 
</p>
<p>
Each time you change the database 'schema', you should reset the database using the following expression:
</p><figure><pre><code>VORepository current reset.</code></pre><figcaption></figcaption></figure>


<h4>When to add a new root</h4>
<p>
There are two main points to consider when facing the questions of the necessity of adding a class as a root. 
</p>
<ul>
<li>First, the obvious consideration is whether we need to query objects separately from their objects that refer to them.</li>
</ul>

<ul>
<li>Second, if you need to make sure that subparts will be shared and not duplicated you should declare the subparts as root. For example if you need to be able to share a power between two super heroes and want to be sure that when you load the two superheroes you do not get two copies of the same power. </li>
</ul>


<h3>Power as a root</h3>

<p>
We declare <code>Power</code> as a new root.
</p>
<figure><pre><code>Power class &gt;&gt; isVoyageRoot 
	^ true</code></pre><figcaption></figcaption></figure>


<p>
Now we can save the super power objects separately as follows:
</p>
<figure><pre><code>Power new name: 'Fly'; save.
Power new name: 'Super-strength'; save.</code></pre><figcaption></figcaption></figure>

<p>
If you do not see the new collection in the database using <code>show collections</code>
you may face a Voyage bug and you need to reset the memory database cache in the Pharo image doing: 
</p>
<figure><pre><code>VORepository current reset.</code></pre><figcaption></figcaption></figure>

<p>
Now saving your objects and checking the mongo db again should show
</p>
<figure><pre><code>&gt; show collections
	Hero
	Power</code></pre><figcaption></figcaption></figure>

<p>
Now we can save a hero and its superpowers. To fully test we flush the heroes in the database 
executing <code>Hero removeAll</code> and we execute the following:
</p>
<figure><pre><code>| fly superStrength |
fly := Power selectOne: [ :each | each name = 'Fly']. 
superStrength := Power selectOne: [ :each | each name = 'Super-strength'].
Hero new
	name: 'Superman'; level: #epic;
	addPower: fly; 
	addPower: superStrength; 
	save.</code></pre><figcaption></figcaption></figure>

<p>
Note that while we saved the powers independently from the hero, this is not mandatory
since saving a hero will automatically save its powers. 
</p>
<p>
Now when we query the database we can see that an hero has references to another collection of Powers and that the powers
are not nested inside the hero documents. 
</p>

<figure><pre><code>&gt; db.Hero.find()[0]
{
	&quot;_id&quot; : ObjectId(&quot;d8474983421aa909b4000008&quot;),
	&quot;#version&quot; : NumberLong(&quot;3874503784&quot;),
	&quot;#instanceOf&quot; : &quot;Hero&quot;,
	&quot;level&quot; : &quot;epic&quot;,
	&quot;name&quot; : &quot;Superman&quot;,
	&quot;powers&quot; : [
		{
			&quot;#collection&quot; : &quot;Power&quot;,
			&quot;#instanceOf&quot; : &quot;Power&quot;,
			&quot;_id&quot; : ObjectId(&quot;d84745dd421aa909b4000005&quot;)
		},
		{
			&quot;#collection&quot; : &quot;Power&quot;,
			&quot;#instanceOf&quot; : &quot;Power&quot;,
			&quot;_id&quot; : ObjectId(&quot;d84745dd421aa909b4000006&quot;)
		}
	]
}</code></pre><figcaption></figcaption></figure>

<h3>About relations</h3>
<p>
Voyage supports cyclic references between root objects but it does not support cyclic references to embedded objects. We will see that in the following section. 
</p>
<h3>Extending the Hero class</h3>
<p>
We will now extend the class <code>Hero</code> with equipments. This example shows that the root collection declaration is <em>static</em>: when a superclass is defined as root, the collection in the mongo db will contain instances of both the class and its subclasses. If we want to have a collection per subclass we have to define each of them as root and you should duplicate the <code>isVoyageRoot</code> method in each class. 
</p>

<p>
We add a new instance variable named <code>equipment</code> to the class <code>Hero</code>.
</p>
<figure><pre><code>Object subclass: #Hero
   instanceVariableNames: 'name level powers equipment' 
   classVariableNames: ''
   package: 'SuperHeroes'</code></pre><figcaption></figcaption></figure>

<figure><pre><code>Hero &gt;&gt; equipment
   ^ equipment ifNil: [ equipment := Set new ]</code></pre><figcaption></figcaption></figure>

<figure><pre><code>Hero &gt;&gt; addEquipment: anEquipment 
   self equipment add: anEquipment</code></pre><figcaption></figcaption></figure>

<p>
Since we change the class structure we should reset the local cache of the database doing <code>VORepository current reset</code>.
</p>
<p>
Now we define the class <code>Equipment</code> as a new root. 
</p>
<figure><pre><code>Object subclass: #Equipment 
	instanceVariableNames: '' 
	classVariableNames: '' 
	package: ‘SuperHeroes'</code></pre><figcaption></figcaption></figure>

<figure><pre><code>Equipment class &gt;&gt; isVoyageRoot 
	^ true</code></pre><figcaption></figcaption></figure>

<p>
And we define two subclasses for <code>Weapon</code> and <code>Armor</code>
</p><figure><pre><code>Equipment subclass: #Weapon
	instanceVariableNames: ''
	classVariableNames: ''
	category: 'SuperHeroes'</code></pre><figcaption></figcaption></figure>

<figure><pre><code>Equipment subclass: #Armor
	instanceVariableNames: ''
	classVariableNames: ''
	category: 'SuperHeroes'</code></pre><figcaption></figcaption></figure>

<p>
Now saving a new hero with equipment will also save its equipment as a separate object. 
</p>
<figure><pre><code>Hero new
	name: 'Iron-Man'; 
	level: #epic; 
	addEquipment: Armor new; 
	save.</code></pre><figcaption></figcaption></figure>

<p>
We can see how the objects are saved in the database
</p>
<figure><pre><code>&gt; db.Hero.find()[1]
{
	&quot;_id&quot; : ObjectId(&quot;d8475734421aa909b4000001&quot;),
	&quot;#instanceOf&quot; : &quot;Hero&quot;,
	&quot;#version&quot; : NumberLong(&quot;2898020230&quot;),
	&quot;equipment&quot; : [
		{
			&quot;#instanceOf&quot; : &quot;Armor&quot;
		}
	],
	&quot;level&quot; : &quot;epic&quot;,
	&quot;name&quot; : &quot;Iron-Man&quot;,
	&quot;powers&quot; : null
}</code></pre><figcaption></figcaption></figure>

<p>
Since we did not define <code>Weapon</code> and <code>Armor</code> has separate roots, there is only one collection named Equipment in the 
database containing both weapons and armors. 
</p>


<h3>Equipment can also have powers</h3>

<p>
In fact equipments can also have powers (like the hammer of Thor). Therefore we add powers to the equipments as follows: 
</p>
<figure><pre><code>Object subclass: #Equipment 
	instanceVariableNames: 'powers' 
	classVariableNames: '' 
	package: 'SuperPowers'</code></pre><figcaption></figcaption></figure>

<figure><pre><code>Equipment &gt;&gt; powers
	^ powers ifNil: [ powers := Set new ]</code></pre><figcaption></figcaption></figure>
<figure><pre><code>Equipment &gt;&gt; addPower: aPower 
	self powers add: aPower</code></pre><figcaption></figcaption></figure>

<p>
Since we change the class structure we should reset the local cache of the database doing 
</p>
<figure><pre><code>VORepository current reset</code></pre><figcaption></figcaption></figure>

<p>
And we can now add a equipment with powers to Ironman as follows:  
</p>
<figure><pre><code>| hero fly superStrength |
hero := Hero selectOne: [ :each | each name = 'Iron-Man' ].
fly := Power selectOne: [ :each | each name = 'Fly' ].
superStrength := Power selectOne: [ :each | each name = 'Super-strength' ].
hero addEquipment: (Armor new
        addPower: fly;
        addPower: superStrength;
        yourself);
save.</code></pre><figcaption></figcaption></figure>

<p>
We see in the database that the Equipment collection contains Armor objects. 
</p>
<figure><pre><code>&gt; db.Equipment.find()[0]
{
	&quot;_id&quot; : ObjectId(&quot;d8475777421aa909b4000003&quot;),
	&quot;#instanceOf&quot; : &quot;Armor&quot;,
	&quot;#version&quot; : NumberLong(&quot;4204064627&quot;)
}</code></pre><figcaption></figcaption></figure>

<p>
Note that an equipment could contain an equipment. To express this we do not have anything to handle cyclic references since the class <code>Equipment</code> is a collection root.
</p>

<h3>Conclusion</h3>

<p>
This little tutorial shows how easy it is to store objects in a Mongo database. It complements the space of possible solutions such as using Fuel to serialize object, using the in-memory SandStone approach or the more traditional relation database mapping with Garage.

</p>
<h2>Persisting Objects with Voyage</h2>
<a id="cha:voyage"></a>
<p>
In this chapter we will do a tour of Voyage API. 
</p>

<h3>Create a repository</h3>

<p>
In Voyage, all persistent objects are stored in a repository. The kind of repository that is used determines the storage backend for the objects.
</p>
<p>
To use the in-memory layer for Voyage, an instance of <code>VOMemoryRepository</code> needs to be created, as follows:
</p>
<figure><pre><code>repository := VOMemoryRepository new</code></pre><figcaption></figcaption></figure>

<p>
In this text, we shall however use the MongoDB backend. To start a new MongoDB repository or connect to an existing repository create an instance of
<code>VOMongoRepository</code>, giving as parameters the hostname and database name. For example, to connect to the database <code>databaseName</code> on the host
<code>mongo.db.url</code> execute the following code:
</p>
<figure><pre><code>repository := VOMongoRepository
	host: 'mongo.db.url'
	database: 'databaseName'.</code></pre><figcaption></figcaption></figure>

<p>
Alternatively, using the message <code>host:port:database:</code> allows to
specify the port to connect to. Lastly, if authentication is required,
this can be done using the message
<code>host:database:username:password:</code> or the message <code>host:port:database:username:password:</code>.
</p>
<h3>Singleton mode and instance mode</h3>

<p>
Voyage can work in two different modes:
</p>
<ul>
<li>Singleton mode: There is an unique repository in the image, which works as a singleton keeping all the data. When you use this mode, you can program using a &quot;behavioral complete&quot; approach where instances respond to a certain vocabulary (see below for more details about vocabulary and usage).</li>
<li>Instance mode: You can have an undetermined number of repositories living in the image. Of course, this mode requires you to make explicit which repositories you are going to use.</li>
</ul>


<p>
By default, Voyage works in instance mode: the returned instance has to be passed as an argument to all database API operations. Instead of having to keep this
instance around, a convenient alternative is to use Singleton mode. Singleton mode removes the need to pass the repository as an argument to all database
operations. To use Singleton mode, execute:
</p>
<figure><pre><code>repository enableSingleton.</code></pre><figcaption></figcaption></figure>

<p class="note">Only one repository can be the singleton, hence executing this line will remove any other existing repositories from Singleton mode! In this document, we cover Voyage in Singleton mode, but using it in Instance mode is straightforward as well. See the protocol <code>persistence</code> of <code>VORepository</code> for more information.</p>
<h3>Voyage API</h3>

<p>
The following two tables show a representative subset of the API of Voyage. These methods are defined on <code>Object</code> and <code>Class</code>, but will only truly perform
work if (instances of) the receiver of the message is a Voyage root. See the <code>voyage-model-core-extensions</code> persistence protocol on both classes for the full
API of Voyage.
</p>
<p>
First we show Singleton mode:
</p><table style="border: solid thin"><tr><td><code>save</code></td>
<td>stores an object into repository (insert or update)</td>
</tr>
<tr><td><code>remove</code></td>
<td>removes an object from repository</td>
</tr>
<tr><td><code>removeAll</code></td>
<td>removes all objects of class from repository</td>
</tr>
<tr><td><code>selectAll</code></td>
<td>retrieves all objects of some kind</td>
</tr>
<tr><td><code>selectOne:</code></td>
<td>retrieves first object that matches the argument</td>
</tr>
<tr><td><code>selectMany:</code></td>
<td>retrieves all objects that matches the argument</td>
</tr>
</table>


<p>
Second is Instance mode. In Instance mode, the receiver is always the repository on which to perform the operation.
</p><table style="border: solid thin"><tr><td><code>save:</code></td>
<td>stores an object into repository (insert or update)</td>
</tr>
<tr><td><code>remove:</code></td>
<td>removes an object from repository</td>
</tr>
<tr><td><code>removeAll:</code></td>
<td>removes all objects of class from repository</td>
</tr>
<tr><td><code>selectAll:</code></td>
<td>retrieves all objects of some kind</td>
</tr>
<tr><td><code>selectOne:where:</code></td>
<td>retrieves first object that matches the where clause</td>
</tr>
<tr><td><code>selectMany:where:</code></td>
<td>retrieves all objects that matches the where clause</td>
</tr>
</table>

<h3>Resetting or dropping the database connection</h3>

<p>
In a deployed application, there should be no need to close or reset the connection to the database. Also, Voyage re-establishes the connection when the image
is closed and later reopened.
</p>
<p>
However, when developing, resetting the connection to the database may be needed to reflect changes. This is foremost required when changing storage options of
the database (see section <a href="#enhancing"></a>). Performing a reset is achieved as follows:
</p>
<figure><pre><code>VORepository current reset.</code></pre><figcaption></figcaption></figure>

<p>
In case the connection to the database needs to be dropped, this is performed as follows:
</p>
<figure><pre><code>VORepository setRepository: nil.</code></pre><figcaption></figcaption></figure>

<h3>Testing and Singleton</h3>

<p>
When we want to test that actions are really saving or removing an object from a Voyage repository we should take care that running the tests are not touching a database that may be in use. This is important since we are in presence of Singleton, which is acting as a global variable.
We should make sure that the tests are run against a repository especially set up for the tests and that they do not affect another repository. 
</p>
<p>
Here is a typical solution: during the setup, we store the current repository, set a new one and this is this new temporary repository that will be used for the tests.
</p>

<figure><pre><code>TestCase subclass: #SuperHeroTest
	instanceVariableNames: 'oldRepository'
	classVariableNames: ''
	package: 'MyVoyageTests'</code></pre><figcaption></figcaption></figure>

<figure><pre><code>SuperHeroTest &gt;&gt; setUp
	oldRepository := VORepository current.
	VORepository setRepository: VOMemoryRepository new.</code></pre><figcaption></figcaption></figure>

<p>
On teardown we set back the saved repository and discard the newly created repository.
</p>
<figure><pre><code>SuperHeroTest &gt;&gt; tearDown
	VORepository setRepository: oldRepository</code></pre><figcaption></figcaption></figure>



<h3>Storing objects</h3>

<p>
To store objects, the class of the object needs to be declared as being a <em>root of the repository</em>. All repository roots are points of entry to the database.
Voyage stores more than just objects that contain literals. Complete trees of objects can be stored with Voyage as well, and this is done transparently. In
other words, there is no need for a special treatment to store trees of objects. However, when a graph of objects is stored, care must be taken to break loops.
In this section we discuss such basic storage of objects, and in section <a href="#enhancing"></a> on Enhancing Storage we show how to enhance and/or modify the way objects
are persisted.
</p>
<h3>Basic storage</h3>

<p>
Let's say we want to store an Association (i.e. a pair of objects). To do this, we need to declare that the class <code>Association</code> is storable as a root of our
repository.  To express this we define the class method <code>isVoyageRoot</code> to return true.
</p>
<figure><pre><code>Association class&gt;&gt;isVoyageRoot
	^ true</code></pre><figcaption></figcaption></figure>

<p>
We can also define the name of the collection that will be used to store documents with the <code>voyageCollectionName</code> class method. By default, Voyage creates a MongoDB collection for each root class with name the name of the class.
</p>
<figure><pre><code>Association class&gt;&gt;voyageCollectionName
	^ 'Associations'</code></pre><figcaption></figcaption></figure>

<p>
Then, to save an association, we need to just send it the <code>save</code> message:
</p>
<figure><pre><code>anAssociation := #answer-&gt;42.
anAssociation save.</code></pre><figcaption></figcaption></figure>

<p>
This will generate a collection in the database containing a document of the following structure:
</p>
<figure><pre><code class="json">{
	&quot;_id&quot; : ObjectId(&quot;a05feb630000000000000000&quot;),
	&quot;#instanceOf&quot; : &quot;Association&quot;,
	&quot;#version&quot; : NumberLong(&quot;3515916499&quot;),
	&quot;key&quot; : 'answer',
	&quot;value&quot; : 42
}</code></pre><figcaption></figcaption></figure>

<p>
The stored data keeps some <em>extra information</em> to allow the object to be correctly reconstructed when loading:
</p>
<ul>
<li><code>instanceOf</code> records the class of the stored instance. This information is important because the collection can contain subclass instances of the Voyage root class.</li>
<li><code>version</code> keeps a marker of the object version that is committed. This property is used internally by Voyage for refreshing cached data in the application. Without a <code>version</code> field, the application would have to refresh the object by frequently querying the database.</li>
</ul>

<p>
Note that the documents generated by Voyage are not directly visible using Voyage itself, as the goal of Voyage is to abstract away from the document structure. To see the actual documents you need to access the database
directly. For MongoDB this can be done through Mongo Browser, which is loaded as part of Voyage (World-&gt;Tools-&gt;Mongo Browser). Other options for MongoDB are to use the <code>mongo</code> command line interface  or a GUI tool such as <a href="http://robomongo.org">RoboMongo</a> (Multi-Platform) or <a href="http://mongohub.todayclose.com/">MongoHub</a> (for Mac). 
</p>
<h3>Embedding objects</h3>

<p>
Objects can be as simple as associations of literals or more complex: objects can contain other objects, leading to a tree of objects. Saving such objects is as
simple as sending the <code>save</code> message to them. For example, let's say that we want to store rectangles and that each rectangle contains two points. To achieve
this, we specify that the <code>Rectangle</code> class is a document root as follows:
</p>
<figure><pre><code>Rectangle class&gt;&gt;isVoyageRoot
	^ true</code></pre><figcaption></figcaption></figure>

<p>
This allows rectangles to be saved to the database, for example as shown by this snippet:
</p>
<figure><pre><code>aRectangle := 42@1 corner: 10@20.
aRectangle save.</code></pre><figcaption></figcaption></figure>

<p>
This will add a document to the <code>rectangle</code> collection of the database with this structure:
</p>
<figure><pre><code class="json">{
	&quot;_id&quot; : ObjectId(&quot;ef72b5810000000000000000&quot;),
	&quot;#instanceOf&quot; : &quot;Rectangle&quot;,
	&quot;#version&quot; : NumberLong(&quot;2460645040&quot;),
	&quot;origin&quot; : {
		&quot;#instanceOf&quot; : &quot;Point&quot;,
		&quot;x&quot; : 42,
		&quot;y&quot; : 1
	},
	&quot;corner&quot; : {
		&quot;#instanceOf&quot; : &quot;Point&quot;,
		&quot;x&quot; : 10,
		&quot;y&quot; : 20
	}
}</code></pre><figcaption></figcaption></figure>



<h3>Referencing other roots</h3>
<a id="referencing"></a>
<p>
Sometimes the objects are trees that contain other root objects. For instance, you could want to keep users and roles as roots, i.e. in different collections,
and a user has a collection of roles. If the embedded objects (the roles) are root objects, Voyage will store references to these objects instead of including
them in the document.
</p>
<p>
Returning to our rectangle example, let's suppose we want to keep the points in a separate collection. In other words, now the points will be referenced
instead of embedded.
</p>
<p>
After we add <code>isVoyageRoot</code> to <code>Point class</code>, and save the rectangle, in the <code>rectangle</code> collection, we get the following document:
</p>
<figure><pre><code class="json"> {
	&quot;_id&quot; : ObjectId(&quot;7c5e772b0000000000000000&quot;),
	&quot;#instanceOf&quot; : &quot;Rectangle&quot;,
	&quot;#version&quot; : 423858205,
	&quot;origin&quot; : {
		&quot;#collection&quot; : &quot;point&quot;,
		&quot;#instanceOf&quot; : &quot;Point&quot;,
		&quot;_id&quot; : ObjectId(&quot;7804c56c0000000000000000&quot;)
	},
	&quot;corner&quot; : {
		&quot;#collection&quot; : &quot;point&quot;,
		&quot;#instanceOf&quot; : &quot;Point&quot;,
		&quot;_id&quot; : ObjectId(&quot;2a731f310000000000000000&quot;)
	}
}</code></pre><figcaption></figcaption></figure>

<p>
In addition to this, in the collection <code>point</code> we also get the two following entities:
</p>
<figure><pre><code class="json">{
	&quot;_id&quot; : ObjectId(&quot;7804c56c0000000000000000&quot;),
	&quot;#version&quot; : NumberLong(&quot;4212049275&quot;),
	&quot;#instanceOf&quot; : &quot;Point&quot;,
	&quot;x&quot; : 42,
	&quot;y&quot; : 1
}

{
	&quot;_id&quot; : ObjectId(&quot;2a731f310000000000000000&quot;),
	&quot;#version&quot; : 821387165,
	&quot;#instanceOf&quot; : &quot;Point&quot;,
	&quot;x&quot; : 10,
	&quot;y&quot; : 20
}</code></pre><figcaption></figcaption></figure>

<h3>Breaking cycles in graphs</h3>

<p>
When the objects to be stored contain a graph of embedded objects instead of a tree, i.e. when there are cycles in the references that the embedded objects have
between them, the cycles between these embedded objects must be broken. If not, storing the objects will cause an infinite loop. The most straightforward solution
is to declare one of the objects causing the cycle as a Voyage root. This effectively breaks the cycle at storage time, avoiding the infinite loop.
</p>
<p>
For example, in the rectangle example say we have a label inside the rectangle, and this label contains a piece of text. The text also keeps a reference to the
label in which it is contained. In other words there is a cycle of references between the label and the text. This cycle must be broken in order to persist the
rectangle. To do this, either the label or the text must be declared as a Voyage root.
</p>
<p>
An alternative solution to break cycles, avoiding the declaration of new voyage roots, is to declare some fields of objects as transient and define how the
graph must be reconstructed at load time. This will be discussed in the following section.
</p>
<h3>Storing instances of Date in Mongo</h3>

<p>
A known issue of mongo is that it does not make a difference between <code>Date</code> and <code>DateAndTime</code>, so even if you store a <code>Date</code> instance, you will retrieve a <code>DateAndTime</code> instance. You will have to transform it back to <code>Date</code> manually when materializing the object.
</p>

<h3>Enhancing storage</h3>
<a id="enhancing"></a>
<p>
How objects are stored can be changed by adding Magritte descriptions to their classes. In this section, we first talk about configuration options for the
storage format of the objects. Then we treat more advanced concepts such as loading and saving of attributes, which can be used, for example, to break cycles in
embedded objects.
</p>
<h4>Configuring storage</h4>

<p>
Consider that, continuing with the rectangle example but using embedded points, we add the following storage requirements:
</p>
<ul>
<li>We need to use a different collection named <code>rectanglesForTest</code> instead of <code>rectangle</code>.</li>
<li>We only store instances of the <code>Rectangle</code> class in this collection, and therefore the <code>instanceOf</code> information is redundant.</li>
<li>The <code>origin</code> and <code>corner</code> attributes are always going to be points, so the <code>instanceOf</code> information there is redundant as well.</li>
</ul>

<p>
To implement this, we use Magritte descriptions with specific pragmas to declare properties of a class and to describe both the <code>origin</code> and <code>corner</code> attributes.
</p>
<p>
The method <code>mongoContainer</code> is defined as follows: First it uses the pragma <code>&lt;mongoContainer&gt;</code> to state that it describes the container to be used for this
class. Second it returns a specific <code>VOMongoContainer</code> instance. This instance is configured such that it uses the <code>rectanglesForTest</code> collection in the
database, and that it will only store <code>Rectangle</code> instances.
</p>
<p>
Note that it is not required to specify both configuration lines. It is equally valid to only
declare that the collection to be used is <code>rectanglesForTest</code>, or only specify that the collection contains just <code>Rectangle</code> instances.
</p>
<figure><pre><code>Rectangle class&gt;&gt;mongoContainer
	&lt;mongoContainer&gt;

	^ VOMongoContainer new
		collectionName: 'rectanglesForTest';
		kind: Rectangle;
		yourself</code></pre><figcaption></figcaption></figure>

<p>
The two other methods use the pragma <code>&lt;mongoDescription&gt;</code> and return a Mongo description that is configured with their respective attribute name and kind, as
follows:
</p>
<figure><pre><code>Rectangle class&gt;&gt;mongoOrigin
	&lt;mongoDescription&gt;

	^ VOMongoToOneDescription new
		attributeName: 'origin';
		kind: Point;
		yourself</code></pre><figcaption></figcaption></figure>

<figure><pre><code>Rectangle class&gt;&gt;mongoCorner
	&lt;mongoDescription&gt;

	^ VOMongoToOneDescription new
		attributeName: 'corner';
		kind: Point;
		yourself</code></pre><figcaption></figcaption></figure>

<p>
After resetting the repository with:
</p>
<figure><pre><code>VORepository current reset</code></pre><figcaption></figcaption></figure>

<p>
a saved rectangle, now in the <code>rectanglesForTest</code> collection, will look more or less as follows:
</p>
<figure><pre><code class="json">{
	&quot;_id&quot; : ObjectId(&quot;ef72b5810000000000000000&quot;),
	&quot;#version&quot; : NumberLong(&quot;2460645040&quot;),
	&quot;origin&quot; : {
		&quot;x&quot; : 42,
		&quot;y&quot; : 1
	},
	&quot;corner&quot; : {
		&quot;x&quot; : 10,
		&quot;y&quot; : 20
	}
}</code></pre><figcaption></figcaption></figure>

<p>
Other configuration options for attribute descriptions are:
</p>
<ul>
<li><code>beEager</code> declares that the referenced instance is to be loaded eagerly (the default is lazy).</li>
<li><code>beLazy</code> declares that referenced instances are loaded lazily.</li>
<li><code>convertNullTo:</code> when retrieving an object whose value is Null (<code>nil</code>), instead return the result of evaluating the block passed as argument.</li>
</ul>

<p>
For attributes which are collections, the <code>VOMongoToManyDescription</code> needs to be returned instead of the <code>VOMongoToOneDescription</code>. All the above
configuration options remain valid, and the <code>kind:</code> configuration option is used to specify the kind of values the collection contains.
</p>
<p>
<code>VOMongoToManyDescription</code> provides a number of extra configuration options:
</p>
<ul>
<li><code>kindCollection:</code> specifies the class of the collection that is contained in the attribute.</li>
<li><code>convertNullToEmpty</code> when retrieving a collection whose value is Null (<code>nil</code>), it returns an empty collection.</li>
</ul>

<h3>Custom loading and saving of attributes</h3>

<p>
It is possible to write specific logic for transforming attributes of an object when written to the database, as well as when read from the database. This can
 be used, e.g., to break cycles in the object graph without needing to declare extra Voyage roots. To declare such custom logic, a <code>MAPluggableAccessor</code> needs
 to be defined that contains Smalltalk blocks for reading the attribute from the object and writing it to the object. Note that the names of these accessors can
 be counter-intuitive: the <code>read:</code> accessor defines the value that will be <strong>stored</strong> in the database, and the <code>write:</code> accessor defines the transformation
 of this <strong>retrieved</strong> value to what is placed in the object. This is because the accessors are used by the Object-Document mapper when <strong>reading the object</strong> to
 store it to the database and when <strong>writing the object</strong> to memory, based on the values obtained from the database.
</p>
<p>
Defining accessors allows, for example, a <code>Currency</code> object that is contained in an <code>Amount</code> to be written to the database as its' three letter abbreviation
(EUR, USD, CLP, ...). When loading this representation, it needs to be converted back into a Currency object, e.g. by instantiating a new Currency object. This
is achieved as follows:
</p>
<figure><pre><code>Amount class&gt;&gt;mongoCurrency
	&lt;mongoDescription&gt;

	^ VOMongoToOneDescription new
		attributeName: 'currency';
		accessor: (MAPluggableAccessor
			read: [ :amount | amount currency abbreviation ]
			write: [ :amount :value | amount currency: (Currency fromAbbreviation: value) ]);
		yourself</code></pre><figcaption></figcaption></figure>

<p>
Also, a post-load action can be defined for an attribute or for the containing object, by adding a <code>postLoad:</code> action to the attribute descriptor or the
container descriptor. This action is a one-parameter block, and will be executed after the object has been loaded into memory with as argument the object that
was loaded.
</p>
<p>
Lastly, attributes can be excluded from storage (and hence retrieval) by returning a <code>VOMongoTransientDescription</code> instance as the attribute descriptor. This
allows to place cut-off points in the graph of objects that is being saved, i.e. when an object contains a reference to data that should not be persisted in the
database. This may also be used to break cycles in the stored object graph. It however entails that when retrieving the graph from the database, attributes that
contain these objects will be set to <code>nil</code>. To address this, a post-load action can be specified for the attribute descriptor or the container descriptor, to
set these attributes to the correct values.
</p>
<p>
Here is an example that declares that the attribute 'currencyMetaData' is excluded from storage.
</p>
<figure><pre><code>Amount class&gt;&gt;mongoCurrencyMetaData
	&lt;mongoDescription&gt;
	
	^VOTransientDescription new
		attributeName: 'currencyMetaData';
		yourself</code></pre><figcaption></figcaption></figure>


<h3>A few words concerning the OID</h3>

<p>
The mongo ObjectId (OID) is a unique field acting as a primary key. It is a 12-byte BSON type, constructed using:
</p>
<ul>
<li>a 4-byte value representing seconds passed since the Unix epoch,</li>
<li>a 3-byte machine identifier,</li>
<li>a 2-byte process id,</li>
<li>a 3-byte counter, starting with a random value.</li>
</ul>

<p>
Objects which are added into a mongo root collection get a unique id,
instance of <code>OID</code>. If you create such an object and then ask it for
its OID by sending it <code>voyageId</code>, you get the OID. The instance
variable <code>value</code> of the OID contains a <code>LargePositiveInteger</code> that
corresponds to the mongo ObjectId.
</p>
<p>
It is possible to create and use your own implementation of OIDs and
put these objects into the mongo database. But this is not recommended as you
possibly may no longer be able to query these objects by their OID (by
using <code>voyageId</code>), since mongo expects a certain format. If you do, you should check your format by querying for it in the mongo console, for example as below. If you get the <code>result Error: invalid object id: length</code>, then you will not be able to query this object by id.
</p>
<figure><pre><code>&gt; db.Trips.find({&quot;person._id&quot; : ObjectId(&quot;190372&quot;)})
Fri Aug 28 14:21:10.815 Error: invalid object id: length</code></pre><figcaption></figcaption></figure>

<p>
An extra advantage of the OID in the mongo format is that these are
ordered by creation date and time and as a result you have an indexed
&quot;creationDateAndTime&quot; attribute for free (since there is a non deletable
index on the field of the OID <code>_id</code>).
</p>
<h3>Querying in Voyage</h3>

<p>
Voyage allows to selectively retrieve object instances though queries on the database. When using the in-memory layer, queries are standard Smalltalk blocks.
When using the MongoDB back-end, the MongoDB query language is used to perform the searches. To specify these queries, MongoDB uses JSON structures, and when
using Voyage there are two ways in which these can be constructed. MongoDB queries can be written either as blocks or as dictionaries, depending on their
complexity. In this section, we first discuss both ways in which queries can be created, and we end the section by talking about how to execute these queries.
</p>
<h3>Basic object retrieval using blocks or mongoQueries</h3>

<p>
The most straightforward way to query the database is by using blocks when using the in-memory layer or MongoQueries when using the MongoDB back-end. In this
discussion we will focus on the use of MongoQueries, as the use of blocks is standard Smalltalk.
</p>
<p>
MongoQueries is not part of Voyage itself but part of the MongoTalk layer that Voyage uses to talk to MongoDB. MongoTalk was made by Nicolas Petton and provides
all the low-level operations for accessing MongoDB. MongoQueries transforms, within certain restrictions, regular Pharo blocks into JSON queries that comply to
the form that is expected by the database. In essence, MongoQueries is an embedded Domain Specific Language to create MongoDB queries. Using MongoQueries, a
query looks like a normal Pharo expression (but the language is much more restricted than plain Smalltalk).
</p>
<p>
Using MongoQueries, the following operators may be used in a query:
</p>
<table style="border: solid thin"><tr><td><code>&lt; &lt;= &gt; &gt;= = ~= </code></td>
<td>Regular comparison operators</td>
<td></td>
</tr>
<tr><td><code>&amp;</code></td>
<td>AND operator</td>
<td></td>
</tr>
<tr><td><code>|</code></td>
<td>OR operator</td>
<td></td>
</tr>
<tr><td><code>not</code></td>
<td>NOT operator</td>
<td></td>
</tr>
<tr><td><code>at:</code></td>
<td>Access an embedded document</td>
<td></td>
</tr>
<tr><td><code>where:</code></td>
<td>Execute a Javascript query</td>
<td></td>
</tr>
</table>

<p>
For example, a query that selects all elements in the database whose name is <code>John</code> is the following:
</p>
<figure><pre><code>[ :each | each name = 'John' ]</code></pre><figcaption></figcaption></figure>



<p>
A slightly more complicated query is to find all elements in the database whose name is <code>John</code> and the value in <code>orders</code> is greater than 10.
</p>
<figure><pre><code>[ :each | (each name = 'John') &amp; (each orders &gt; 10 ) ]</code></pre><figcaption></figcaption></figure>


<p>
Note that this way of querying only works for querying values of the object but not values of references to other objects.
For such case you should build your query using ids, as traditionally done in relational database, which we talk about next. However the best solution in the Mongo spirit of things is to revisit the object model to avoid relationships that are expressed with foreign keys.
</p>
<h3>Quering with elements from another root document</h3>

<p>
With No-SQL databases, it is impossible to query on multiple collections (the equivalent of a JOIN statement in SQL). You have two options: alter your schema, as suggested above, or write application-level code to reproduce the JOIN behavior. The latter option can be done by sending the <code>voyageId</code> message to an object already
returned by a previous query and using that id to match another object. An example where we match colors <code>color</code> to a reference color <code>refCol</code> is as follows:
</p>
<figure><pre><code>[ :each | (each at: 'color._id') = refCol voyageId ]</code></pre><figcaption></figcaption></figure>

<h3>Using the at: message to access embedded documents</h3>

<p>
Since MongoDB stores documents of any complexity, it is common that one document is composed of several embedded documents, for example:
</p>
<figure><pre><code class="json">{
	&quot;origin&quot; : {
		&quot;x&quot; : 42,
		&quot;y&quot; : 1
	},
	&quot;corner&quot; : {
		&quot;x&quot; : 10,
		&quot;y&quot; : 20
	}
}</code></pre><figcaption></figcaption></figure>

<p>
In this case, to search for objects by one of the embedded document elements, the message <code>at:</code>, and the field separator <strong>&quot;.</strong>&quot; needs to be used. For
example, to select all the rectangles whose origin x value is equal to 42, the query is as as follows.
</p>
<figure><pre><code>[ :each | (each at: 'origin.x') = 42 ]</code></pre><figcaption></figcaption></figure>

<h3>Using the where: message to perform Javascript comparisons</h3>

<p>
To perform queries which are outside the capabilities of MongoQueries or even the MongoDB query language, MongoDB provides a way to write queries directly in
Javascript using the <code>$where</code> operand. This is also possible in MongoQueries by sending the <code>where:</code> message:
</p>
<p>
In the following example we repeat the previous query with a Javascript expression:
</p>
<figure><pre><code>[ :each | each where: 'this.origin.x == 42' ].</code></pre><figcaption></figcaption></figure>

<p>
More complete documentation about the use of <code>$where</code> is in the
<a href="http://docs.mongodb.org/manual/reference/operator/where/#op._S_where">MongoDB where documentation</a>.
</p>


<h3>Using JSON queries</h3>

<p>
When MongoQueries is not powerful enough to express your query, you can use a JSON query instead. JSON queries are the MongoDB query internal representation, and
can be created straightforwardly in Voyage. In a nutshell: a JSON structure is mapped to a dictionary with pairs. In these pairs the key is a string and the
value can be a primitive value, a collection or another JSON structure (i.e., another dictionary). To create a query, we simply need to create a dictionary that
satisfies these requirements.
</p>
<p class="note">The use of JSON queries is strictly for when using the MongoDB back-end. Other back-ends, e.g., the in-memory layer, do not provide support for the use of JSON queries.</p>
<p>
For example, the first example of the use of MongoQueries is written as a dictionary as follows:
</p>
<figure><pre><code>{ 'name' -&gt; 'John' } asDictionary</code></pre><figcaption></figcaption></figure>

<p>
Dictionary pairs are composed with AND semantics. Selecting the elements having <code>John</code> as name AND whose <code>orders</code> value is greater than 10 can be written
like this:
</p>
<figure><pre><code>{
	'name' -&gt; 'John'.
	'orders' -&gt; { '$gt' : 10 } asDictionary
} asDictionary</code></pre><figcaption></figcaption></figure>

<p>
To construct the &quot;greater than&quot; statement, a new dictionary needs to be created that uses the MongoDB <code>$gt</code> query selector to express the greater than
relation. For the list of available query selectors we refer to the
<a href="http://docs.mongodb.org/manual/reference/operator/query/#query-selectors">MongoDB Query Selectors documentation</a>.
</p>
<h4>Querying for an object by OID</h4>

<p>
If you know the ObjectId for a document, you can create an OID instance with this value
and query for it.
</p><figure><pre><code>{('_id' -&gt; (OID value: 16r55CDD2B6E9A87A520F000001))} asDictionary.</code></pre><figcaption></figcaption></figure>

<p>
Note that both of the following are equivalent:
</p><figure><pre><code>OID value: 26555050698940995562836590593. &quot;dec&quot;
OID value: 16r55CDD2B6E9A87A520F000001. &quot;hex&quot;</code></pre><figcaption></figcaption></figure>

<p class="note">If you have an instance which is in a root collection, then you can ask it for its <code>voyageId</code> and use that ObjectId in your query.</p>
<h4>Using dot notation to access embedded documents</h4>

<p>
To access values embedded in documents with JSON queries, the dot notation is used. For example, the query representing rectangles whose origin have 42 as their
<code>x</code> values can be expressed this way:
</p>
<figure><pre><code>{
	'origin.x' -&gt; {'$eq' : 42} asDictionary
} asDictionary</code></pre><figcaption></figcaption></figure>


<h4>Expressing OR conditions in the query</h4>

<p>
To express an OR condition, a dictionary whose key is <code>'$or'</code> and whose values are the expression of the condition is needed. The following example shows how
to select all objects whose name is <code>John</code> that have more than ten orders OR objects whose name is not <code>John</code> and has ten or less orders:
</p>
<figure><pre><code>{ '$or' :
	{
		{
			'name' -&gt; 'John'.
			'orders' -&gt; { '$gt': 10 } asDictionary
		} asDictionary.
		{
			'name' -&gt; { '$ne': 'John'} asDictionary.
			'orders' -&gt; { '$lte': 10 } asDictionary
		} asDictionary.
	}.
} asDictionary.</code></pre><figcaption></figcaption></figure>


<h4>Going beyond MongoQueries features</h4>

<p>
Using JSON queries allows to use features that are not present in MongoQueries, for example the use of regular expressions. Below is a query that searches for
all documents with a <code>fullname.lastName</code> that starts with the letter <code>D</code>:
</p>
<figure><pre><code>{
	'fullname.lastName' -&gt; {
		'$regexp': '^D.*'.
		'$options': 'i'.
	} asDictionary.
} asDictionary.</code></pre><figcaption></figcaption></figure>

<p>
The option <code>i</code> for a regular expression means case insensitivity. More options are described in the documentation of the
<a href="http://docs.mongodb.org/manual/reference/operator/query/regex/#op._S_regex">$regex operator</a>.
</p>
<p>
This example only briefly illustrates the power of JSON queries. Many more different queries can be constructed, and the complete list of operators and usages
is in the <a href="http://docs.mongodb.org/manual/reference/operator">MongoDB operator documentation</a>
</p>

<h3>Executing a Query</h3>

<p>
Voyage has a group of methods to perform searches. To illustrate the use of these methods we will use the stored Point example we have presented before. Note
that all queries in this section can be written either as MongoQueries or as JSON queries, unless otherwise specified.
</p>
<h3>Basic Object Retrieval</h3>

<p>
The following methods provide basic object retrieval.
</p>
<ul>
<li><strong><code>selectAll</code></strong> Retrieves all documents in the corresponding database collection. For example, <code>Point selectAll</code> will return all Points.</li>
<li><strong><code>selectOne:</code></strong> Retrieves one document matching the query. This maps to a <code>detect:</code> method and takes as argument a query specification (either a MongoQuery or a JSON Query). For example, <code>Point selectOne: [:each | each x = 42] </code> or alternatively <code>Point selectOne: { 'x' -&gt; 42 } asDictionary</code>.</li>
<li><strong><code>selectMany:</code></strong> Retrieves all the documents matching the query. This maps to a <code>select:</code> method and takes as argument a query specification, like above.</li>
</ul>

<h3>Limiting Object Retrieval and Sorting</h3>

<p>
The methods that query the database look similar to their equivalent in the Collection hierarchy. However unlike regular collections which can operate fully on
memory, often Voyage collection queries need to be customized in order to optimize memory consumption and/or access speed. This is because there can be
literally millions of documents in each collection, surpassing the memory limit of Pharo, and also the database searches have a much higher performance than the
equivalent code in Pharo.
</p>
<p>
The first refinement to the queries consist in limiting the amount of results that are returned. Of the collection of all the documents that match, a subset is
returned that starts at the index that is given as argument. This can be used to only retrieve the first N matches to a query, or go over the query results in
smaller blocks, as will be shown next in the simple paginator example.
</p>

<ul>
<li><code>selectMany:limit:</code> Retrieves a collection of objects from the database that match the query, up to the given limit. An example of this is <code>Point selectMany: [:each | each x = 42] limit: 10 </code></li>
<li><code>selectMany:limit:offset:</code> Retrieves a collection of objects from the database that match the query. The first object retrieved will be at the <code>offset</code> position plus one of the results of the query, and up to <code>limit</code> objects will be returned. For example, if the above example matched 25 points, the last 15 points will be returned by the query <code>Point selectMany: [:each | each x = 42] limit: 20 offset: 10</code> (any <code>limit</code> argument greater than 15 will do for this example).</li>
</ul>

<p>
The second customization that can be performed is to sort the results. To use this, the class <code>VOOrder</code> provides constants to specify <code>ascending</code> or <code>descending</code> sort order.
</p>
<ul>
<li><code>selectAllSortBy:</code> Retrieves all documents, sorted by the specification in the argument, which needs to be a JSON query. For example, <code> Point selectAllSortBy: { #x -&gt; VOOrder ascending} asDictionary </code> returns the points in ascending x order.</li>
<li><code>selectMany:sortBy:</code> Retrieves all the documents matching the query and sorts them. For example to return the points where <code>x</code> is 42, in descending <code>y</code> order: <code>Point selectMany: { 'x' -&gt; 42 } asDictionary sortBy: { #y -&gt; VOOrder descending } asDictionary</code>.</li>
<li><code>selectMany:sortBy:limit:offset:</code> Provides for specifying a limit and offset to the above query.</li>
</ul>

<h3>A Simple Paginator Example</h3>

<p>
Often you want to display just a range of objects that belong to the collection, e.g. the first 25, or from 25 to 50, and so on. Here we present a simple paginator that implements this behavior, using the <code>selectMany:limit:offset:</code> method.
</p>
<p>
First we create a class named <code>Paginator</code>. To instantiate it, a Voyage root (<code>aClass</code>) and a query (<code>aCondition</code>) need to be given.
</p>
<figure><pre><code>Object subclass: #Paginator
	instanceVariableNames: 'collectionClass where pageCount'
	classVariableNames: ''
	package: 'DemoPaginator'

Paginator class&gt;&gt;on: aClass where: aCondition
	^ self basicNew
		initializeOn: aClass where: aCondition

Paginator&gt;&gt;initializeOn: aClass where: aCondition
	self initialize.
	collectionClass := aClass.
	where := aCondition</code></pre><figcaption></figcaption></figure>

<p>
Then we define the arithmetic to get the number of pages for a page size and a given number of entities.
</p>
<figure><pre><code>Paginator&gt;&gt;pageSize
	^ 25

Paginator&gt;&gt;pageCount
	^ pageCount ifNil: [ pageCount := self calculatePageCount ]

Paginator&gt;&gt;calculatePageCount
	| count pages |
	count := self collectionClass count: self where.
	pages := count / self pageSize.
	count \\ self pageSize &gt; 0
		ifTrue: [ pages := pages + 1].
	^ count</code></pre><figcaption></figcaption></figure>

<p>
The query that retrieves only the elements for a given page is then implemented as follows:
</p>
<figure><pre><code>Paginator&gt;&gt;page: aNumber
	^ self collectionClass
		selectMany: self where
		limit: self pageSize
		offset: (aNumber - 1) * self pageSize</code></pre><figcaption></figcaption></figure>

<h3>Creating and Removing Indexes</h3>

<p>
There are a number of useful features in MongoDB that are not present in Voyage but still can be performed from within Pharo, the most important one being the management of indexes.
</p>
<h3>Creating Indexes by using OSProcess</h3>
<p>
It is not yet possible to create and remove indexes from Voyage, but this can nonetheless be done by using OSProcess.
</p>
<p>
For example, assume there is a database named <code>myDB</code> with a collection named <code>Trips</code>.
The trips have an embedded collection with receipts. The receipts have an attribute named <code>description</code>. The following creates an index on <code>description</code>:
</p>
<figure><pre><code>OSProcess command:
	'/{pathToMongoDB}/MongoDB/bin/mongo --eval ',
	'&quot;db.getSiblingDB(''myDB'').Trips.',
	'createIndex({''receipts.description'':1})&quot;'</code></pre><figcaption></figcaption></figure>

<p>
Removing all indexes on the Trips collection can be done as follows:
</p><figure><pre><code>OSProcess command:
	'/{pathToMongoDB}/MongoDB/bin/mongo --eval ',
	'&quot;db.getSiblingDB(''myDB'').Trips.dropIndexes()&quot;'</code></pre><figcaption></figcaption></figure>

<h3>Verifying the use of an Index</h3>

<p>
To ensure that a query indeed uses the index, <code>&quot;.explain()&quot;</code> can be used in the mongo console. For example, if we add the index on <code>description</code> as above, run a query and add <code>.explain()</code> we see, that only a subset of documents were scanned.
</p>
<figure><pre><code class="javascript">&gt; db.Trips.find({&quot;receipts.description&quot;:&quot;a&quot;})
						 .explain(&quot;executionStats&quot;)
{
	&quot;cursor&quot; : &quot;BtreeCursor receipts.receiptDescription_1&quot;,
	&quot;isMultiKey&quot; : true,
	&quot;n&quot; : 2,
	&quot;nscannedObjects&quot; : 2,
	&quot;nscanned&quot; : 2,
	&quot;nscannedObjectsAllPlans&quot; : 2,
	&quot;nscannedAllPlans&quot; : 2,

  [...]
}</code></pre><figcaption></figcaption></figure>

<p>
After removing the index, all documents are scanned (in this example there are 246):
</p>
<figure><pre><code class="javascript">&gt; db.Trips.find({&quot;receipts.description&quot;:&quot;a&quot;}
					  ..explain(&quot;executionStats&quot;)
{
	&quot;cursor&quot; : &quot;BasicCursor&quot;,
	&quot;isMultiKey&quot; : false,
	&quot;n&quot; : 2,
	&quot;nscannedObjects&quot; : 246,
	&quot;nscanned&quot; : 246,
	&quot;nscannedObjectsAllPlans&quot; : 246,
	&quot;nscannedAllPlans&quot; : 246,

  [...]
}</code></pre><figcaption></figcaption></figure>


<h3>Conclusion</h3>

<p>
In this chapter we presented Voyage, a persistence programming framework. The strength of Voyage lies in the presence of the object-document mapper and MongoDB back-end. We have shown how to store objects in, and remove object from the database, and how to optimise the storage format. This was followed by a discussion
of querying the database; showing the two ways in which queries can be constructed and detailing how queries are ran. We ended this chapter by presenting how we can construct indexes in MongoDB databases, even though Voyage does not provide direct support for it.
</p>


<h2>Tips and Tricks</h2>

<p>
This chapter contains some tips and tricks that people collected over the years. It was written by Sabina Manaa.
</p>

<h3>How to query for an object by id?    </h3>

<p>
If you know the _id value, you initialize an OID with this and query for it.
</p><figure><pre><code>Person selectOne: {('_id' -&gt; (OID value: 16r55CDD2B6E9A87A520F000001))} asDictionary.</code></pre><figcaption></figcaption></figure>

<p>
Note that both are equivalent:
</p><figure><pre><code>OID value: 26555050698940995562836590593. &quot;dec&quot;
OID value: 16r55CDD2B6E9A87A520F000001. &quot;hex&quot;</code></pre><figcaption></figcaption></figure>

<p>
Or you have an instance (in this example of <code>Person</code>) which is in a root collection, then you ask it for its voyageId and use it in your query. The following assumes that you have a <code>Trips</code> root collection and a <code>Persons</code> root collection. The trip has an embedded <code>receipts</code> collection. Receipts have a <code>description</code>.  The query asks for all trips of the given person with at least one receipt with the description <code>aString</code>.
</p>
<figure><pre><code> Trip
		selectMany:
			{('receipts.description' -&gt; aString).
			('person._id' -&gt; aPerson voyageId)} asDictionary</code></pre><figcaption></figcaption></figure>

<h3>Not yet supported mongo commands</h3>

<h4>Indexes</h4>
<p>
It is not yet possible to create and remove indexes from voyage, but you can use OSProcess.
</p>
<p>
Assume you have a database named <code>myDB</code> with a collection named <code>Trips</code>. 
The trips have an embedded collection with receipts. The receipts have an attribute named <code>description</code>.
Then you can create an index on description with
</p>
<figure><pre><code>OSProcess command:
'/{pathToMongoDB}/MongoDB/bin/mongo --eval &quot;db.getSiblingDB(''myDB'').Trips.createIndex({''receipts.description'':1})&quot;'</code></pre><figcaption></figcaption></figure>


<p>
Remove all indexes on the Trips collection with:
</p><figure><pre><code>OSProcess command:
'/{pathToMongoDB}/MongoDB/bin/mongo --eval &quot;db.getSiblingDB(''myDB'').Trips.dropIndexes()&quot;'</code></pre><figcaption></figcaption></figure>

<h4>Backup</h4>
<p>
It is not yet possible to create backup from voyage, so use 
</p>
<figure><pre><code>OSProcess command:
 '/{pathToMongoDB}/MongoDB/bin/mongodump  --out {BackupPath}'</code></pre><figcaption></figcaption></figure>

<p>
Please see the mongo documentation for mongo commands, especially the <code>--eval</code> command.
</p>
<h3>Useful mongo commands</h3>

<p>
Use “.explain()” in the mongo console to ensure that your query indeed uses the index.
</p>
<p>
Example:
</p>
<p>
Create an index on an embedded attribute (<code>description</code>):
</p><figure><pre><code>&gt; db.Trips.createIndex({&quot;receipts.description&quot;:1})</code></pre><figcaption></figcaption></figure>

<p>
Query for it and call explain. We see, that only 2 documents were scanned.
&gt; db.Trips.find({&quot;receipts.description&quot;:&quot;a&quot;}).explain(&quot;executionStats&quot;)
{
	&quot;cursor&quot; : &quot;BtreeCursor receipts.receiptDescription_1&quot;,
	&quot;isMultiKey&quot; : true,
	&quot;n&quot; : 2,
	&quot;nscannedObjects&quot; : 2,
	&quot;nscanned&quot; : 2,
	&quot;nscannedObjectsAllPlans&quot; : 2,
	&quot;nscannedAllPlans&quot; : 2,
	&quot;scanAndOrder&quot; : false,
	&quot;indexOnly&quot; : false,
	&quot;nYields&quot; : 0,
	&quot;nChunkSkips&quot; : 0,
	&quot;millis&quot; : 0,
	&quot;indexBounds&quot; : {
		&quot;receipts.receiptDescription&quot; : [
			[
				&quot;a&quot;,
				&quot;a&quot;
			]
		]
	},
	&quot;allPlans&quot; : [
		{
			&quot;cursor&quot; : &quot;BtreeCursor receipts.receiptDescription_1&quot;,
			&quot;n&quot; : 2,
			&quot;nscannedObjects&quot; : 2,
			&quot;nscanned&quot; : 2,
			&quot;indexBounds&quot; : {
				&quot;receipts.receiptDescription&quot; : [
					[
						&quot;a&quot;,
						&quot;a&quot;
					]
				]
			}
		}
	],
	&quot;server&quot; : &quot;MacBook-Pro-Sabine.local:27017&quot;
}
]]]
</p>
<p>
Now, remove the index
</p><figure><pre><code>&gt; db.Trips.dropIndexes()
{
	&quot;nIndexesWas&quot; : 2,
	&quot;msg&quot; : &quot;non-_id indexes dropped for collection&quot;,
	&quot;ok&quot; : 1
}</code></pre><figcaption></figcaption></figure>

<p>
Query again, all documents were scanned.
</p>
<figure><pre><code>&gt; db.Trips.find({&quot;receipts.receiptDescription&quot;:&quot;a&quot;}).explain(&quot;executionStats&quot;)
{
	&quot;cursor&quot; : &quot;BasicCursor&quot;,
	&quot;isMultiKey&quot; : false,
	&quot;n&quot; : 2,
	&quot;nscannedObjects&quot; : 246,
	&quot;nscanned&quot; : 246,
	&quot;nscannedObjectsAllPlans&quot; : 246,
	&quot;nscannedAllPlans&quot; : 246,
	&quot;scanAndOrder&quot; : false,
	&quot;indexOnly&quot; : false,
	&quot;nYields&quot; : 0,
	&quot;nChunkSkips&quot; : 0,
	&quot;millis&quot; : 1,
	&quot;indexBounds&quot; : {
		
	},
	&quot;allPlans&quot; : [
		{
			&quot;cursor&quot; : &quot;BasicCursor&quot;,
			&quot;n&quot; : 2,
			&quot;nscannedObjects&quot; : 246,
			&quot;nscanned&quot; : 246,
			&quot;indexBounds&quot; : {
				
			}
		}
	],
	&quot;server&quot; : &quot;MacBook-Pro-Sabine.local:27017&quot;
}</code></pre><figcaption></figcaption></figure>



<h3>Storing instances of Date in Mongo</h3>
<p>
A known issue of mongo is Mongo that it does not difference between <code>Date</code> and <code>DateAndTime</code>, so even if you commit a <code>Date</code>, you will get back a <code>DateAndTime</code>. You have to transform it back to <code>Date</code> manually when materializing the object.
</p>
<h3>Database design</h3>
<p>
Often you objects do not form a simple tree but a graph with cycles. For example you could have persons which are pointing to their trips and each trip knows about its person (<code>Person &lt;-&gt;&gt;Trip</code>). If you create a root Collection with Persons and a Root collection with Trips, you avoid endless loops to be generated (see chapter 1.2).
</p>
<p>
This is an example for a <code>trip</code> pointing to a <code>person</code> which is in another root collection and another root collection, <code>paymentMethod</code>. Note that the receipt also points back to the trip, which does not create a loop.
</p>
<figure><pre><code>Trip
{
 &quot;_id&quot; : ObjectId(&quot;55cf2bc73c9b0fe702000008&quot;), 
&quot;#version&quot; : 876079653, 
&quot;person&quot; : { 
	&quot;#collection&quot; : &quot;Persons&quot;, 
	&quot;_id&quot; : ObjectId(&quot;55cf2bbb3c9b0fe702000007&quot;) }, 
&quot;receipts&quot; : [ 	
	{ &quot;currency&quot; : &quot;EUR&quot;, 	
	&quot;date&quot; : { &quot;#instanceOf&quot; : &quot;ZTimestamp&quot;, &quot;jdn&quot; : 2457249, &quot;secs&quot; : 0 }, 	
	&quot;exchangeRate&quot; : 1, 	
	&quot;paymentMethod&quot; : {
		&quot;#collection&quot; : &quot;PaymentMethods&quot;, 	
		&quot;_id&quot; : ObjectId(&quot;55cf2bbb3c9b0fe702000003&quot;) }, 
	&quot;receiptDescription&quot; : &quot;Taxi zum Hotel&quot;, 	
	&quot;receiptNumber&quot; : 1, 	
	&quot;trip&quot; : { 
		&quot;#collection&quot; : &quot;Trips&quot;, 	
		&quot;_id&quot; : ObjectId(&quot;55cf2bc73c9b0fe702000008&quot;) } } ], 
	&quot;startPlace&quot; : &quot;Österreich&quot;,    
	&quot;tripName&quot; : &quot;asdf&quot;, 
	&quot;tripNumber&quot; : 1 }</code></pre><figcaption></figcaption></figure>

<p>
The corresponding <code>person</code> points to all its <code>trips</code> and to its <code>company</code>.
</p><figure><pre><code>{ &quot;#version&quot; : 714221829, 
&quot;_id&quot; : ObjectId(&quot;55cf2bbb3c9b0fe702000007&quot;), 
&quot;bankName&quot; : &quot;&quot;,
 &quot;company&quot; : { 
&quot;#collection&quot; : &quot;Companies&quot;, 
&quot;_id&quot; : ObjectId(&quot;55cf2bbb3c9b0fe702000002&quot;) },
&quot;email&quot; : &quot;bb@spesenfuchs.de&quot;, 
&quot;firstName&quot; : &quot;Berta&quot;,
&quot;lastName&quot; : &quot;Block&quot;,  
&quot;roles&quot; : [  &quot;user&quot; ], 
&quot;tableOfAccounts&quot; : &quot;SKR03&quot;, 
&quot;translator&quot; : &quot;German&quot;, 
&quot;trips&quot; : [ 	
{
&quot;#collection&quot; : &quot;Trips&quot;, 	
&quot;_id&quot; : ObjectId(&quot;55cf2bc73c9b0fe702000008&quot;) } ] }</code></pre><figcaption></figcaption></figure>

<p>
If your domain has strictly delimited areas, e.g. clients, you could think about creating one repository per area (client). 
</p>
<h3>Retrieving data </h3>

<p>
One question is if it possible to  retrieve data from Mongo collection even if the database was not created via Voyage.
Yes it is possible. Here is the solution.
</p>
<p>
First we create a class <code>MyClass</code> with two class side methods:
</p>
<figure><pre><code>MyClass class &gt;&gt; isVoyageRoot
	^ true</code></pre><figcaption></figcaption></figure>

<figure><pre><code>MyClass class &gt;&gt; descriptionContainer
    &lt;voyageContainer&gt;
    ^ VOContainer new
        collectionName: 'myCollection';
        yourself</code></pre><figcaption></figcaption></figure>
<p>
	
Also, to properly read the data one should add instance variables depending on what is in the database. 
</p>
<p>
For example if we have the following information stored in the database: 
</p>
<figure><pre><code>{ &quot;_id&quot; : ObjectId(&quot;5900a0175bc65a2b7973b48a&quot;), &quot;item&quot; : &quot;canvas&quot;, &quot;qty&quot; : 100, &quot;tags&quot; : [ &quot;cotton&quot; ] }</code></pre><figcaption></figcaption></figure>

<p>
In this case <code>MyClass</code> should have instanceVariables: <code>item</code>, <code>qty</code> and <code>tags</code> and accessors.
Then we define the following description on the class side
</p>
<figure><pre><code>MyClass class &gt;&gt; mongoItem
	&lt;mongoDescription&gt;
	^ VOToOneDescription new
		attributeName: 'item';
		kind: String;
		yourself</code></pre><figcaption></figcaption></figure>

<figure><pre><code>MyClass class &gt;&gt; mongoQty
	&lt;mongoDescription&gt;
	^ VOToOneDescription new
		attributeName: 'qty';
		kind: Integer;
		yourself</code></pre><figcaption></figcaption></figure>

<figure><pre><code>MyClass class &gt;&gt; mongoTags
	&lt;mongoDescription&gt;
	^ VOToOneDescription new
		attributeName: 'tags';
		kind: OrderedCollection;
		yourself</code></pre><figcaption></figcaption></figure>
<p>
	
After that one can connect to database and get the information.
</p>
<figure><pre><code>| repository | 
repository := VOMongoRepository database: 'databaseName'.
repository selectAll: MyClass</code></pre><figcaption></figcaption></figure>







  </section>

</article>

<footer>

<div class="footline">
    <div class="github-link">
      <a href="" target="blank"><i class="fa fa-code-fork"></i>Github</a>
    </div>
  </div>
</footer>

<script src="/booklet-Voyage/html/_support/html/js/clipboard.min.js"></script>

<link href="/booklet-Voyage/html/_support/html/css/featherlight.min.css" rel="stylesheet">
<script src="/booklet-Voyage/html/_support/html/js/featherlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script src="/booklet-Voyage/html/_support/html/js/flex.js"></script>
<!-- Prettify annotated paragraphs-->
    <script src="/booklet-Voyage/html_support/html/js/annotated-paragraphs.js"></script>

  </body>
</html>
